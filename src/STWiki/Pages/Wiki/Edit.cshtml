@page "/{slug}/edit"
@model STWiki.Pages.Wiki.EditModel
@{
    ViewData["Title"] = Model.IsNew ? "Create New Page" : $"Edit {Model.Title}";
}

<div class="container-fluid">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h1>@(Model.IsNew ? "Create New Page" : "Edit Page")</h1>
        <div>
            @if (!Model.IsNew)
            {
                <a asp-page="/Wiki/View" asp-route-slug="@Model.Slug" class="btn btn-outline-secondary">Cancel</a>
            }
            else
            {
                <a asp-page="/Wiki/Index" class="btn btn-outline-secondary">Cancel</a>
            }
        </div>
    </div>

    @if (!ModelState.IsValid)
    {
        <div class="alert alert-danger">
            <div asp-validation-summary="All"></div>
        </div>
    }

    <form method="post" class="mb-4">
        <div class="row">
            <div class="col-md-8">
                <div class="mb-3">
                    <label asp-for="Title" class="form-label">Page Title</label>
                    <input asp-for="Title" class="form-control" placeholder="Enter page title..." />
                    <span asp-validation-for="Title" class="text-danger"></span>
                </div>

                @if (Model.IsNew)
                {
                    <div class="mb-3">
                        <label asp-for="Slug" class="form-label">URL Slug</label>
                        <input asp-for="Slug" class="form-control" placeholder="auto-generated-from-title" />
                        <div class="form-text">Leave blank to auto-generate from title</div>
                        <span asp-validation-for="Slug" class="text-danger"></span>
                    </div>
                }

                <div class="mb-3">
                    <label asp-for="Summary" class="form-label">Summary (Optional)</label>
                    <input asp-for="Summary" class="form-control" placeholder="Brief description of this page..." />
                    <span asp-validation-for="Summary" class="text-danger"></span>
                </div>

                <div class="mb-3">
                    <label asp-for="BodyFormat" class="form-label">Content Format</label>
                    <select asp-for="BodyFormat" class="form-select">
                        <option value="markdown">Markdown</option>
                        <option value="html">HTML</option>
                    </select>
                    <span asp-validation-for="BodyFormat" class="text-danger"></span>
                </div>

                <div class="mb-3">
                    <label asp-for="Body" class="form-label">Content</label>
                    @if (Model.BodyFormat == "markdown")
                    {
                        <div id="editor-container">
                            <component type="typeof(STWiki.Components.EditorSimple)" 
                                       render-mode="Server"
                                       param-PageId="@(Model.PageId ?? Guid.Empty)"
                                       param-InitialContentRaw="@Model.Body"
                                       param-YjsRoomRaw="@(Model.Slug ?? "new-page")" />
                        </div>
                        <textarea asp-for="Body" class="form-control d-none" rows="20" id="body-textarea"></textarea>
                    }
                    else
                    {
                        <textarea asp-for="Body" class="form-control" rows="20" placeholder="Enter your content here..."></textarea>
                    }
                    <span asp-validation-for="Body" class="text-danger"></span>
                </div>
            </div>
            
            <div class="col-md-4">
                <div class="card">
                    <div class="card-body">
                        <h6 class="card-title">Page Information</h6>
                        @if (!Model.IsNew)
                        {
                            <p class="small text-muted">
                                <strong>Created:</strong> @Model.CreatedAt?.ToString("yyyy-MM-dd HH:mm")<br/>
                                <strong>Last Updated:</strong> @Model.UpdatedAt?.ToString("yyyy-MM-dd HH:mm")<br/>
                                <strong>Updated By:</strong> @Model.UpdatedBy
                            </p>
                        }
                        
                        <div class="d-grid gap-2">
                            <button type="submit" class="btn btn-success">
                                @(Model.IsNew ? "Create Page" : "Save Changes")
                            </button>
                            @if (!Model.IsNew)
                            {
                                <a asp-page="/Wiki/History" asp-route-slug="@Model.Slug" class="btn btn-outline-info btn-sm">View History</a>
                            }
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </form>
</div>

@section Scripts {
    <partial name="_ValidationScriptsPartial" />
    @if (Model.BodyFormat == "markdown")
    {
        <script src="_framework/blazor.server.js"></script>
        <script>
            // Blazor connection diagnostics and state monitoring
            (function() {
                console.log('üîß Blazor diagnostics: Starting connection monitoring...');
                
                function logBlazorState() {
                    const state = {
                        blazor: typeof Blazor !== 'undefined' ? 'loaded' : 'not loaded',
                        signalR: typeof signalR !== 'undefined' ? 'loaded' : 'not loaded',
                        connection: null,
                        circuit: null,
                        connected: false
                    };
                    
                    if (typeof Blazor !== 'undefined') {
                        try {
                            // Better detection: Blazor is connected if it exists and has handlers
                            // The presence of Blazor object itself usually means it's functional
                            state.circuit = 'available';
                            state.connected = true;
                            
                            // Also check if we can access the internal circuit (optional)
                            if (Blazor.defaultReconnectionHandler) {
                                state.connection = 'with reconnection handler';
                            }
                        } catch (e) {
                            state.circuit = 'error: ' + e.message;
                            state.connected = false;
                        }
                    }
                    
                    console.log('üîß Blazor State:', state);
                    return state.connected;
                }
                
                // Log initial state
                document.addEventListener('DOMContentLoaded', () => {
                    console.log('üîß DOM loaded, checking Blazor state...');
                    logBlazorState();
                });
                
                // Monitor Blazor connection events - DON'T call Blazor.start() as it auto-starts
                if (typeof Blazor !== 'undefined') {
                    console.log('‚úÖ Blazor already available');
                    logBlazorState();
                } else {
                    // Blazor not ready yet, wait for it
                    let attempts = 0;
                    const waitForBlazor = setInterval(() => {
                        attempts++;
                        if (typeof Blazor !== 'undefined') {
                            console.log(`‚úÖ Blazor available after ${attempts} attempts`);
                            clearInterval(waitForBlazor);
                            logBlazorState();
                        } else if (attempts > 50) { // 5 seconds max
                            console.error('‚ùå Blazor failed to load after 5 seconds');
                            clearInterval(waitForBlazor);
                            logBlazorState();
                        }
                    }, 100);
                }
                
                // Add a function for components to check connection
                window.checkBlazorConnection = function() {
                    const isConnected = logBlazorState();
                    console.log('üîó Connection check requested, result:', isConnected);
                    return isConnected;
                };
                
                window.blazorDiagnostics = { logBlazorState, checkBlazorConnection };
            })();
        </script>
        <script src="~/js/editor-enhanced.js"></script>
        <script>
            // Handle EditorSimple button clicks via event delegation
            document.addEventListener('click', function(e) {
                const button = e.target.closest('button[data-action]');
                if (!button || button.disabled) {
                    console.log('Button click ignored - no action or disabled:', button);
                    return;
                }
                
                const action = button.dataset.action;
                console.log('üîò Button clicked with action:', action);
                
                const editorContainer = button.closest('.editor-container');
                if (!editorContainer) {
                    console.error('Editor container not found');
                    return;
                }
                
                // Find the .NET component reference (set by initEnhancedEditor)
                const componentRef = editorContainer._blazorComponentRef;
                if (!componentRef) {
                    console.error('EditorSimple component reference not found');
                    return;
                }
                
                console.log('üöÄ Calling .NET method for action:', action);
                
                // Call the appropriate .NET method
                switch (action) {
                    case 'save-draft':
                        componentRef.invokeMethodAsync('HandleSaveDraft')
                            .then(() => console.log('‚úÖ HandleSaveDraft completed'))
                            .catch(err => console.error('‚ùå HandleSaveDraft failed:', err));
                        break;
                    case 'commit-changes':
                        componentRef.invokeMethodAsync('HandleCommitChanges')
                            .then(() => console.log('‚úÖ HandleCommitChanges completed'))
                            .catch(err => console.error('‚ùå HandleCommitChanges failed:', err));
                        break;
                    case 'insert-bold':
                        componentRef.invokeMethodAsync('HandleInsertBold')
                            .then(() => console.log('‚úÖ HandleInsertBold completed'))
                            .catch(err => console.error('‚ùå HandleInsertBold failed:', err));
                        break;
                    default:
                        console.warn('Unknown action:', action);
                }
            });
        </script>
        <script>
            // Sync editor content with hidden textarea on form submission  
            document.addEventListener('DOMContentLoaded', function() {
                const form = document.querySelector('form');
                if (form) {
                    form.addEventListener('submit', function(e) {
                        try {
                            console.log('üîÑ Form submission detected, syncing editor content...');
                            
                            // Find the active enhanced editor (look for any textarea in .editor-container)
                            const editorContainer = document.querySelector('.editor-container');
                            const bodyTextarea = document.getElementById('body-textarea');
                            
                            if (editorContainer && bodyTextarea) {
                                const activeEditor = editorContainer.querySelector('textarea[id*="simple-editor-"]');
                                if (activeEditor) {
                                    bodyTextarea.value = activeEditor.value;
                                    console.log('‚úÖ Synced editor content to form textarea:', activeEditor.value.length, 'characters');
                                } else {
                                    console.warn('‚ö†Ô∏è Enhanced editor textarea not found in container');
                                }
                            } else {
                                console.warn('‚ö†Ô∏è Editor container or body textarea not found');
                                console.log('Editor container:', !!editorContainer);
                                console.log('Body textarea:', !!bodyTextarea);
                            }
                        } catch (error) {
                            console.error('‚ùå Error syncing editor content:', error);
                        }
                    });
                }
            });
        </script>
        <script>
            // DOM trap script - runs after Blazor initialization
            (function(){
                console.log('üîß Installing DOM operation traps...');
                
                function hexify(s){
                    if (typeof s !== "string") return s;
                    return [...s].map(c => `U+${c.codePointAt(0).toString(16).toUpperCase().padStart(4,'0')}(${c})`).join(' ');
                }
                function logFail(kind, obj){
                    const pretty = {};
                    for (const [k,v] of Object.entries(obj)) pretty[k] = typeof v === 'string' ? `${v}  [${hexify(v)}]` : v;
                    console.error(`[trap] ${kind} failed`, pretty);
                    
                    // Also log Blazor state when errors occur
                    if (window.blazorDiagnostics) {
                        console.error('[trap] Blazor state at failure:', window.blazorDiagnostics.logBlazorState());
                    }
                }

                const _sa  = Element.prototype.setAttribute;
                Element.prototype.setAttribute = function(name, value){
                    try { return _sa.call(this, name, value); }
                    catch(e){ logFail('setAttribute', {el:this, name, value, e}); throw e; }
                };

                const _sans = Element.prototype.setAttributeNS;
                Element.prototype.setAttributeNS = function(ns, name, value){
                    try { return _sans.call(this, ns, name, value); }
                    catch(e){ logFail('setAttributeNS', {el:this, ns, name, value, e}); throw e; }
                };

                const _ca = Document.prototype.createAttribute;
                Document.prototype.createAttribute = function(name){
                    try { return _ca.call(this, name); }
                    catch(e){ logFail('createAttribute', {name, e}); throw e; }
                };

                const _ce = Document.prototype.createElement;
                Document.prototype.createElement = function(name){
                    try { return _ce.call(this, name); }
                    catch(e){ logFail('createElement', {name, e}); throw e; }
                };

                const _cc = Document.prototype.createComment;
                Document.prototype.createComment = function(data){
                    try { return _cc.call(this, data); }
                    catch(e){ logFail('createComment', {data, e}); throw e; }
                };

                const _add = DOMTokenList.prototype.add;
                DOMTokenList.prototype.add = function(...tokens){
                    try { return _add.apply(this, tokens); }
                    catch(e){ logFail('classList.add', {el:this, tokens: tokens.map(t => `${t}  [${hexify(t)}]`), e}); throw e; }
                };

                // Optional: catch innerHTML too (invalid markup can also throw)
                const _inner = Object.getOwnPropertyDescriptor(Element.prototype, "innerHTML");
                Object.defineProperty(Element.prototype, "innerHTML", {
                    set(html){ try { return _inner.set.call(this, html); }
                        catch(e){ logFail('innerHTML', {el:this, html, e}); throw e; } },
                    get(){ return _inner.get.call(this); }
                });

                window.addEventListener('error', ev => console.error('[trap] window.error', ev.error || ev));
                window.addEventListener('unhandledrejection', ev => console.error('[trap] unhandledrejection', ev.reason || ev));
                
                console.log('‚úÖ DOM operation traps installed');
            })();
        </script>
    }
}
