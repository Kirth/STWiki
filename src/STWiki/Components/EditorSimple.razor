@using Microsoft.JSInterop
@using System.Text.Json
@using System.Text
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject HttpClient HttpClient
@inject IHttpContextAccessor HttpContextAccessor

<div class="editor-container">
    <div class="editor-toolbar mb-2">
        <div class="d-flex justify-content-between align-items-center">
            <div class="btn-group btn-group-sm" role="group">
                <button type="button" class="btn btn-outline-secondary" disabled="@(!IsFullyReady)" data-action="save-draft">
                    Save Draft
                </button>
                <button type="button" class="btn btn-primary" disabled="@(!IsFullyReady)" data-action="commit-changes">
                    Commit Changes
                </button>
            </div>
            <div class="editor-status">
                @if (IsFullyReady)
                {
                    <span class="badge bg-success">Ready</span>
                }
                else if (IsReady && !IsBlazorConnected)
                {
                    <span class="badge bg-warning">Connecting...</span>
                }
                else
                {
                    <span class="badge bg-warning">Loading...</span>
                }
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header py-2">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">Editor</h6>
                        <div class="btn-group btn-group-sm" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" disabled="@(!IsFullyReady)" data-action="insert-bold" title="Bold (Ctrl+B)">
                                <strong>B</strong>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Italic (Ctrl+I)">
                                <em>I</em>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Inline Code">
                                <code>&lt;/&gt;</code>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Code Block">
                                <code>{ }</code>
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm ms-2" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 1">
                                H1
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 2">
                                H2
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 3">
                                H3
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm ms-2" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Unordered List">
                                List
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Ordered List">
                                1. List
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Blockquote">
                                Quote
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Link">
                                Link
                            </button>
                        </div>
                    </div>
                </div>
                <div class="card-body p-0">
                    <textarea id="@_editorId" 
                              class="form-control border-0" 
                              rows="20" 
                              placeholder="@(BodyFormat == "markdown" ? "Start writing your wiki content in Markdown..." : "Start writing your wiki content in HTML...")"
                              data-room="@_safeRoom"
                              style="resize: vertical; min-height: 400px; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 14px; line-height: 1.5;">@_safeContent</textarea>
                </div>
                <div class="card-footer py-2">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">
                            <span id="word-count">0 words</span> | 
                            <span id="char-count">0 characters</span>
                        </small>
                        <small class="text-muted">
                            <span id="status-text">Ready</span>
                        </small>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-6">
            <div class="card">
                <div class="card-header py-2">
                    <h6 class="mb-0">Preview</h6>
                </div>
                <div class="card-body" style="min-height: 400px; max-height: 500px; overflow-y: auto;">
                    <div id="preview-content" class="markdown-content">
                        <em>Preview will appear here...</em>
                    </div>
                </div>
                <div class="card-footer py-2">
                    <small class="text-muted">
                        Collaboration: <span id="presence-status" class="badge bg-secondary">Offline</span>
                    </small>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] 
    public string InitialContentRaw { get; set; } = "";
    
    [Parameter] 
    public string YjsRoomRaw { get; set; } = "";
    
    [Parameter] 
    public Guid PageId { get; set; }
    
    [Parameter]
    public string BodyFormat { get; set; } = "markdown";
    
    // Safe versions for DOM use
    private string _editorId = $"simple-editor-{Guid.NewGuid():N}";
    private string _safeRoom = "";
    private string _safeContent = "";
    
    private bool IsReady = false;
    private bool IsBlazorConnected = false;
    private bool IsFullyReady => IsReady && IsBlazorConnected;
    private bool IsNewPage => PageId == Guid.Empty;
    private Timer? AutosaveTimer = null;
    
    // Unique component instance ID for debugging
    private readonly string ComponentId = Guid.NewGuid().ToString("N")[..8];
    private int RenderCount = 0;
    private int MethodCallCount = 0;

    protected override void OnInitialized()
    {
        // Sanitize inputs during initialization
        _safeContent = StripFormatChars(InitialContentRaw);
        _safeRoom = SafeDomToken(YjsRoomRaw);
        
        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        // Re-sanitize inputs when parameters change
        _safeContent = StripFormatChars(InitialContentRaw);
        _safeRoom = SafeDomToken(YjsRoomRaw);
        
        base.OnParametersSet();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Wait a bit to ensure Blazor is fully loaded
                await Task.Delay(100);
                
                // Check Blazor connection state
                try 
                {
                    IsBlazorConnected = await JS.InvokeAsync<bool>("checkBlazorConnection");
                }
                catch
                {
                    IsBlazorConnected = false;
                }
                
                // Re-render with connection state
                if (IsBlazorConnected)
                {
                    StateHasChanged();
                    await Task.Delay(50);
                }
                
                // Create .NET object reference and initialize editor
                var objRef = DotNetObjectReference.Create(this);
                var success = await JS.InvokeAsync<bool>("initEnhancedEditor", _editorId, _safeContent, objRef);
                
                if (success)
                {
                    IsReady = true;
                    
                    // Start autosave timer for existing pages
                    if (!IsNewPage)
                    {
                        AutosaveTimer = new Timer(async _ => await AutoSave(), null, 
                            TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
                    }
                }
                
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"‚ùå EditorSimple initialization failed: {ex.Message}");
                IsReady = false;
                IsBlazorConnected = false;
                StateHasChanged();
            }
        }
    }

    private async Task SaveDraft()
    {
        if (!IsFullyReady || IsNewPage) 
        {
            await JS.InvokeVoidAsync("showEditorStatus", "Save not available for new pages");
            return;
        }
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            var request = new { Content = content };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/autosave", httpContent);
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Draft saved");
                }
                catch
                {
                    await JS.InvokeVoidAsync("showEditorStatus", "Save failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                await JS.InvokeVoidAsync("showEditorStatus", "Save failed - authentication required");
            }
            else
            {
                await JS.InvokeVoidAsync("showEditorStatus", $"Save failed: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå SaveDraft failed: {ex.Message}");
            await JS.InvokeVoidAsync("showEditorStatus", $"Save failed: {ex.Message}");
        }
    }

    private async Task CommitChanges()
    {
        if (!IsFullyReady || IsNewPage) 
        {
            await JS.InvokeVoidAsync("showEditorStatus", "Use the main Save button to create new pages");
            return;
        }
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            var request = new { Content = content, Summary = "Updated via enhanced editor" };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/commit", httpContent);
            var responseContent = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"CommitChanges() response status: {response.StatusCode}");
            Console.WriteLine($"CommitChanges() response content: {responseContent}");
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Changes committed successfully");
                    // Notify that changes have been committed via API
                    await JS.InvokeVoidAsync("markContentAsCommitted");
                }
                catch
                {
                    // Not JSON, probably HTML - treat as error even with 200 status
                    await JS.InvokeVoidAsync("showEditorStatus", "Commit failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                await JS.InvokeVoidAsync("showEditorStatus", "Commit failed - authentication required. Please refresh and log in again.");
            }
            else
            {
                await JS.InvokeVoidAsync("showEditorStatus", $"Commit failed: {response.StatusCode} - {responseContent}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå CommitChanges failed: {ex.Message}");
            await JS.InvokeVoidAsync("showEditorStatus", $"Commit failed: {ex.Message}");
        }
    }

    private async Task AutoSave()
    {
        if (!IsReady || IsNewPage) return;
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            if (string.IsNullOrEmpty(content))
            {
                Console.WriteLine("Autosave skipped - no content");
                return;
            }
            
            var request = new { Content = content };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/autosave", httpContent);
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Auto-saved");
                }
                catch
                {
                    Console.WriteLine("Autosave failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                Console.WriteLine("Autosave failed - authentication required");
            }
            else
            {
                Console.WriteLine($"Autosave failed with status: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Autosave error: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        AutosaveTimer?.Dispose();
        
        try
        {
            if (IsReady)
            {
                await JS.InvokeVoidAsync("destroyEnhancedEditor", _editorId);
            }
        }
        catch
        {
            // Best effort cleanup
        }
    }

    // Helper method to make authenticated HTTP requests with cookies
    private async Task<HttpResponseMessage> MakeAuthenticatedRequest(string url, HttpContent content)
    {
        var httpContext = HttpContextAccessor.HttpContext;
        if (httpContext == null)
        {
            // Fallback to regular HttpClient if no context available
            return await HttpClient.PostAsync(url, content);
        }

        // Create a new HttpClient that includes authentication cookies
        var handler = new HttpClientHandler()
        {
            UseCookies = true
        };

        using var authenticatedClient = new HttpClient(handler);
        
        // Set base URL
        var baseUrl = await JS.InvokeAsync<string>("eval", "window.location.origin");
        authenticatedClient.BaseAddress = new Uri(baseUrl);
        
        // Copy authentication cookies from current request
        var cookieHeader = httpContext.Request.Headers["Cookie"].ToString();
        if (!string.IsNullOrEmpty(cookieHeader))
        {
            authenticatedClient.DefaultRequestHeaders.Add("Cookie", cookieHeader);
        }
        
        // Copy authorization headers if present
        if (httpContext.Request.Headers.ContainsKey("Authorization"))
        {
            var authHeader = httpContext.Request.Headers["Authorization"].ToString();
            authenticatedClient.DefaultRequestHeaders.Add("Authorization", authHeader);
        }
        
        return await authenticatedClient.PostAsync(url, content);
    }

    private async Task InsertMarkdown(string before, string after)
    {
        try
        {
            await JS.InvokeVoidAsync("insertMarkdown", before, after);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error inserting markdown: {ex.Message}");
        }
    }


    // Individual button handlers
    private async Task InsertBold() => await InsertMarkdown("**", "**");
    private async Task InsertItalic() => await InsertMarkdown("*", "*");

    private async Task InsertInlineCode() => await InsertMarkdown("`", "`");
    private async Task InsertCodeBlock() => await InsertMarkdown("```\n", "\n```");
    private async Task InsertHeader1() => await InsertMarkdown("# ", "");
    private async Task InsertHeader2() => await InsertMarkdown("## ", "");
    private async Task InsertHeader3() => await InsertMarkdown("### ", "");
    private async Task InsertList() => await InsertMarkdown("- ", "");
    private async Task InsertOrderedList() => await InsertMarkdown("1. ", "");
    private async Task InsertBlockquote() => await InsertMarkdown("> ", "");
    private async Task InsertLink() => await InsertMarkdown("[", "](url)");
    
    /// <summary>
    /// Remove BOM and other format characters that can cause DOM InvalidCharacterError
    /// </summary>
    static string StripFormatChars(string s)
    {
        if (string.IsNullOrEmpty(s)) return string.Empty;
        
        // More aggressive BOM and format character removal
        var cleaned = s;
        
        // Remove BOM variants
        cleaned = cleaned.Replace("\uFEFF", ""); // UTF-8 BOM
        cleaned = cleaned.Replace("\uFFFE", ""); // UTF-16 BOM
        cleaned = cleaned.Replace("\u0000FEFF", ""); // Alternative BOM representation
        
        // Remove zero-width characters
        cleaned = cleaned.Replace("\u200B", ""); // Zero Width Space
        cleaned = cleaned.Replace("\u200C", ""); // Zero Width Non-Joiner  
        cleaned = cleaned.Replace("\u200D", ""); // Zero Width Joiner
        cleaned = cleaned.Replace("\u2060", ""); // Word Joiner
        cleaned = cleaned.Replace("\u180E", ""); // Mongolian Vowel Separator
        
        // Keep only printable characters + tab/newline/carriage return
        cleaned = new string(cleaned.Where(c => c >= ' ' || c is '\t' or '\n' or '\r').ToArray());
        
        return cleaned;
    }

    /// <summary>
    /// Create DOM-safe token from user input (for IDs, classes, attribute names)
    /// </summary>
    static string SafeDomToken(string s)
    {
        s = StripFormatChars(s ?? "");
        s = System.Text.RegularExpressions.Regex.Replace(s, @"[^\w\-]", ""); // only [A-Za-z0-9_-]
        return string.IsNullOrEmpty(s) ? "room" : s;
    }

    // JavaScript-invokable methods for button actions
    [JSInvokable]
    public async Task HandleSaveDraft()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"üéØ [{ComponentId}:{callId}] HandleSaveDraft called from JavaScript");
        await SaveDraft();
        Console.WriteLine($"‚úÖ [{ComponentId}:{callId}] HandleSaveDraft completed");
    }

    [JSInvokable] 
    public async Task HandleCommitChanges()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"üéØ [{ComponentId}:{callId}] HandleCommitChanges called from JavaScript");
        await CommitChanges();
        Console.WriteLine($"‚úÖ [{ComponentId}:{callId}] HandleCommitChanges completed");
    }

    [JSInvokable]
    public async Task HandleInsertBold()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"üéØ [{ComponentId}:{callId}] HandleInsertBold called from JavaScript");
        await InsertBold();
        Console.WriteLine($"‚úÖ [{ComponentId}:{callId}] HandleInsertBold completed");
    }

}
