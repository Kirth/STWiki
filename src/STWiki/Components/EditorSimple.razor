@using Microsoft.JSInterop
@using System.Text.Json
@using System.Text
@using Microsoft.AspNetCore.SignalR.Client
@using STWiki.Models.Collaboration
@using System.Security.Claims
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject HttpClient HttpClient
@inject IHttpContextAccessor HttpContextAccessor

<div class="editor-container" data-editor-id="@_editorId">
    <!-- Hidden field for this editor instance -->
    <input type="hidden" name="Body" data-role="body" />
    <!-- Format badge for this editor -->
    <span data-role="format-badge" style="display: none;">@BodyFormat</span>
    
    <div class="editor-toolbar mb-2">
        <div class="d-flex justify-content-between align-items-center">
            <div class="btn-group btn-group-sm" role="group">
                <button type="button" class="btn btn-outline-secondary" disabled="@(!IsFullyReady)" data-action="save-draft">
                    Save Draft
                </button>
                <button type="button" class="btn btn-primary" disabled="@(!IsFullyReady)" data-action="commit-changes">
                    Commit Changes
                </button>
            </div>
            <div class="editor-status">
                @if (IsFullyReady)
                {
                    <span class="badge bg-success">Ready</span>
                }
                else if (IsReady && !IsBlazorConnected)
                {
                    <span class="badge bg-warning">Connecting...</span>
                }
                else
                {
                    <span class="badge bg-warning">Loading...</span>
                }
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header py-2">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">Editor</h6>
                        <div class="btn-group btn-group-sm" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" disabled="@(!IsFullyReady)" data-action="insert-bold" title="Bold (Ctrl+B)">
                                <strong>B</strong>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Italic (Ctrl+I)">
                                <em>I</em>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Inline Code">
                                <code>&lt;/&gt;</code>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Code Block">
                                <code>{ }</code>
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm ms-2" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 1">
                                H1
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 2">
                                H2
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 3">
                                H3
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm ms-2" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Unordered List">
                                List
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Ordered List">
                                1. List
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Blockquote">
                                Quote
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Link">
                                Link
                            </button>
                        </div>
                    </div>
                </div>
                <div class="card-body p-0" style="position: relative;">
                    <textarea id="@_editorId" 
                              class="form-control border-0" 
                              rows="20" 
                              placeholder="@(BodyFormat == "markdown" ? "Start writing your wiki content in Markdown..." : "Start writing your wiki content in HTML...")"
                              data-room="@_safeRoom"
                              style="resize: vertical; min-height: 400px; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 14px; line-height: 1.5;">@_safeContent</textarea>
                    <div id="remote-cursor-overlay-@_editorId" class="remote-cursor-overlay"></div>
                </div>
                <div class="card-footer py-2">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">
                            <span data-role="word-count">0 words</span> | 
                            <span data-role="char-count">0 characters</span>
                        </small>
                        <small class="text-muted">
                            <span data-role="status-text">Ready</span>
                        </small>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-6">
            <div class="card">
                <div class="card-header py-2">
                    <h6 class="mb-0">Preview</h6>
                </div>
                <div class="card-body" style="min-height: 400px; max-height: 500px; overflow-y: auto;">
                    <div data-role="preview" class="markdown-content">
                        <em>Preview will appear here...</em>
                    </div>
                </div>
                <div class="card-footer py-2">
                    <small class="text-muted">
                        Collaboration: <span id="presence-status" class="badge @CollaborationStatusClass">@CollaborationStatus</span>
                        @if (ConnectedUsers.Any())
                        {
                            <div class="collaboration-users mt-2">
                                @foreach (var user in ConnectedUsers.Take(5))
                                {
                                    <span class="user-indicator me-1" style="background: @user.Color; color: white; border-radius: 50%; width: 24px; height: 24px; display: inline-flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold;" title="@user.DisplayName">
                                        @user.DisplayName.Substring(0, Math.Min(2, user.DisplayName.Length)).ToUpper()
                                    </span>
                                }
                                @if (ConnectedUsers.Count > 5)
                                {
                                    <span class="badge bg-secondary">+@(ConnectedUsers.Count - 5) more</span>
                                }
                            </div>
                        }
                    </small>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] 
    public string InitialContentRaw { get; set; } = "";
    
    [Parameter] 
    public string YjsRoomRaw { get; set; } = "";
    
    [Parameter] 
    public Guid PageId { get; set; }
    
    [Parameter]
    public string BodyFormat { get; set; } = "markdown";
    
    [Parameter]
    public bool EnableCollaboration { get; set; } = true;
    
    // Safe versions for DOM use
    private string _editorId = $"simple-editor-{Guid.NewGuid():N}";
    private string _safeRoom = "";
    private string _safeContent = "";
    
    private bool IsReady = false;
    private bool IsBlazorConnected = false;
    private bool IsFullyReady => IsReady && IsBlazorConnected;
    private bool IsNewPage => PageId == Guid.Empty;
    private Timer? AutosaveTimer = null;
    
    // Collaboration properties
    private HubConnection? _editHubConnection;
    private Timer? _cursorBroadcastTimer;
    private List<UserState> ConnectedUsers = new();
    private string CollaborationStatus = "Offline";
    private string CollaborationStatusClass = "bg-secondary";
    private bool IsCollaborationEnabled = false;
    
    // Cursor state tracking
    private int _lastCursorStart = -1;
    private int _lastCursorEnd = -1;
    private Queue<TextOperation> _pendingOperations = new();
    
    // Enhanced state tracking for race condition prevention
    private long _lastKnownSequenceNumber = 0;
    private readonly Dictionary<string, TextOperation> _pendingOperationMap = new();
    private readonly Dictionary<string, string> _operationContentBackup = new();
    private int _localOperationCounter = 0;
    private int _serverOperationCounter = 0;
    
    // Unique component instance ID for debugging
    private readonly string ComponentId = Guid.NewGuid().ToString("N")[..8];
    private int RenderCount = 0;
    private int MethodCallCount = 0;

    protected override void OnInitialized()
    {
        // Sanitize inputs during initialization
        _safeContent = StripFormatChars(InitialContentRaw);
        _safeRoom = SafeDomToken(YjsRoomRaw);
        
        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        // Re-sanitize inputs when parameters change
        _safeContent = StripFormatChars(InitialContentRaw);
        _safeRoom = SafeDomToken(YjsRoomRaw);
        
        base.OnParametersSet();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Wait a bit to ensure Blazor is fully loaded
                await Task.Delay(100);
                
                // Check Blazor connection state
                try 
                {
                    IsBlazorConnected = await JS.InvokeAsync<bool>("checkBlazorConnection");
                }
                catch
                {
                    IsBlazorConnected = false;
                }
                
                // Re-render with connection state
                if (IsBlazorConnected)
                {
                    StateHasChanged();
                    await Task.Delay(50);
                }
                
                // Create .NET object reference and initialize editor
                var objRef = DotNetObjectReference.Create(this);
                var success = await JS.InvokeAsync<bool>("initEnhancedEditor", _editorId, _safeContent, objRef);
                
                if (success)
                {
                    IsReady = true;
                    
                    // Initialize collaboration if enabled
                    if (EnableCollaboration && !IsNewPage)
                    {
                        await InitializeCollaboration();
                    }
                    
                    // Start autosave timer for existing pages
                    if (!IsNewPage)
                    {
                        AutosaveTimer = new Timer(async _ => await AutoSave(), null, 
                            TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
                    }
                }
                
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ EditorSimple initialization failed: {ex.Message}");
                IsReady = false;
                IsBlazorConnected = false;
                StateHasChanged();
            }
        }
    }

    private async Task SaveDraft()
    {
        if (!IsFullyReady || IsNewPage) 
        {
            await JS.InvokeVoidAsync("showEditorStatus", "Save not available for new pages");
            return;
        }
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            var request = new { Content = content };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/autosave", httpContent);
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Draft saved");
                }
                catch
                {
                    await JS.InvokeVoidAsync("showEditorStatus", "Save failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                await JS.InvokeVoidAsync("showEditorStatus", "Save failed - authentication required");
            }
            else
            {
                await JS.InvokeVoidAsync("showEditorStatus", $"Save failed: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ SaveDraft failed: {ex.Message}");
            await JS.InvokeVoidAsync("showEditorStatus", $"Save failed: {ex.Message}");
        }
    }

    private async Task CommitChanges()
    {
        if (!IsFullyReady || IsNewPage) 
        {
            await JS.InvokeVoidAsync("showEditorStatus", "Use the main Save button to create new pages");
            return;
        }
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            var request = new { Content = content, Summary = "Updated via enhanced editor" };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/commit", httpContent);
            var responseContent = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"CommitChanges() response status: {response.StatusCode}");
            Console.WriteLine($"CommitChanges() response content: {responseContent}");
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Changes committed successfully");
                    // Notify that changes have been committed via API
                    await JS.InvokeVoidAsync("markContentAsCommitted");
                }
                catch
                {
                    // Not JSON, probably HTML - treat as error even with 200 status
                    await JS.InvokeVoidAsync("showEditorStatus", "Commit failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                await JS.InvokeVoidAsync("showEditorStatus", "Commit failed - authentication required. Please refresh and log in again.");
            }
            else
            {
                await JS.InvokeVoidAsync("showEditorStatus", $"Commit failed: {response.StatusCode} - {responseContent}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ CommitChanges failed: {ex.Message}");
            await JS.InvokeVoidAsync("showEditorStatus", $"Commit failed: {ex.Message}");
        }
    }

    private async Task AutoSave()
    {
        if (!IsReady || IsNewPage) return;
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            if (string.IsNullOrEmpty(content))
            {
                Console.WriteLine("Autosave skipped - no content");
                return;
            }
            
            // If collaboration is active, get the authoritative content from the session
            if (IsCollaborationEnabled && _editHubConnection?.State == HubConnectionState.Connected)
            {
                try
                {
                    // Request latest document state to ensure we're saving the most current version
                    await _editHubConnection.InvokeAsync("RequestDocumentSync", PageId.ToString());
                    
                    // Wait a moment for sync, then get content again
                    await Task.Delay(100);
                    content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Failed to sync before autosave: {ex.Message}");
                    // Continue with current content
                }
            }
            
            var request = new { Content = content };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/autosave", httpContent);
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    var statusMessage = IsCollaborationEnabled ? "Auto-saved (collaborative)" : "Auto-saved";
                    await JS.InvokeVoidAsync("showEditorStatus", statusMessage);
                }
                catch
                {
                    Console.WriteLine("Autosave failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                Console.WriteLine("Autosave failed - authentication required");
            }
            else
            {
                Console.WriteLine($"Autosave failed with status: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Autosave error: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        AutosaveTimer?.Dispose();
        _cursorBroadcastTimer?.Dispose();
        
        try
        {
            if (_editHubConnection != null)
            {
                await _editHubConnection.StopAsync();
                await _editHubConnection.DisposeAsync();
            }
            
            if (IsReady)
            {
                await JS.InvokeVoidAsync("destroyEnhancedEditor", _editorId);
            }
        }
        catch
        {
            // Best effort cleanup
        }
    }

    // Helper method to make authenticated HTTP requests with cookies
    private async Task<HttpResponseMessage> MakeAuthenticatedRequest(string url, HttpContent content)
    {
        var httpContext = HttpContextAccessor.HttpContext;
        if (httpContext == null)
        {
            // Fallback to regular HttpClient if no context available
            return await HttpClient.PostAsync(url, content);
        }

        // Create a new HttpClient that includes authentication cookies
        var handler = new HttpClientHandler()
        {
            UseCookies = true
        };

        using var authenticatedClient = new HttpClient(handler);
        
        // Set base URL
        var baseUrl = await JS.InvokeAsync<string>("eval", "window.location.origin");
        authenticatedClient.BaseAddress = new Uri(baseUrl);
        
        // Copy authentication cookies from current request
        var cookieHeader = httpContext.Request.Headers["Cookie"].ToString();
        if (!string.IsNullOrEmpty(cookieHeader))
        {
            authenticatedClient.DefaultRequestHeaders.Add("Cookie", cookieHeader);
        }
        
        // Copy authorization headers if present
        if (httpContext.Request.Headers.ContainsKey("Authorization"))
        {
            var authHeader = httpContext.Request.Headers["Authorization"].ToString();
            authenticatedClient.DefaultRequestHeaders.Add("Authorization", authHeader);
        }
        
        return await authenticatedClient.PostAsync(url, content);
    }

    private async Task InsertMarkdown(string before, string after)
    {
        try
        {
            await JS.InvokeVoidAsync("insertMarkdown", before, after);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error inserting markdown: {ex.Message}");
        }
    }


    // Individual button handlers
    private async Task InsertBold() => await InsertMarkdown("**", "**");
    private async Task InsertItalic() => await InsertMarkdown("*", "*");

    private async Task InsertInlineCode() => await InsertMarkdown("`", "`");
    private async Task InsertCodeBlock() => await InsertMarkdown("```\n", "\n```");
    private async Task InsertHeader1() => await InsertMarkdown("# ", "");
    private async Task InsertHeader2() => await InsertMarkdown("## ", "");
    private async Task InsertHeader3() => await InsertMarkdown("### ", "");
    private async Task InsertList() => await InsertMarkdown("- ", "");
    private async Task InsertOrderedList() => await InsertMarkdown("1. ", "");
    private async Task InsertBlockquote() => await InsertMarkdown("> ", "");
    private async Task InsertLink() => await InsertMarkdown("[", "](url)");
    
    /// <summary>
    /// Remove BOM and other format characters that can cause DOM InvalidCharacterError
    /// </summary>
    static string StripFormatChars(string s)
    {
        if (string.IsNullOrEmpty(s)) return string.Empty;
        
        // More aggressive BOM and format character removal
        var cleaned = s;
        
        // Remove BOM variants
        cleaned = cleaned.Replace("\uFEFF", ""); // UTF-8 BOM
        cleaned = cleaned.Replace("\uFFFE", ""); // UTF-16 BOM
        cleaned = cleaned.Replace("\u0000FEFF", ""); // Alternative BOM representation
        
        // Remove zero-width characters
        cleaned = cleaned.Replace("\u200B", ""); // Zero Width Space
        cleaned = cleaned.Replace("\u200C", ""); // Zero Width Non-Joiner  
        cleaned = cleaned.Replace("\u200D", ""); // Zero Width Joiner
        cleaned = cleaned.Replace("\u2060", ""); // Word Joiner
        cleaned = cleaned.Replace("\u180E", ""); // Mongolian Vowel Separator
        
        // Keep only printable characters + tab/newline/carriage return
        cleaned = new string(cleaned.Where(c => c >= ' ' || c is '\t' or '\n' or '\r').ToArray());
        
        return cleaned;
    }

    /// <summary>
    /// Create DOM-safe token from user input (for IDs, classes, attribute names)
    /// </summary>
    static string SafeDomToken(string s)
    {
        s = StripFormatChars(s ?? "");
        s = System.Text.RegularExpressions.Regex.Replace(s, @"[^\w\-]", ""); // only [A-Za-z0-9_-]
        return string.IsNullOrEmpty(s) ? "room" : s;
    }

    // JavaScript-invokable methods for button actions
    [JSInvokable]
    public async Task HandleSaveDraft()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"🎯 [{ComponentId}:{callId}] HandleSaveDraft called from JavaScript");
        await SaveDraft();
        Console.WriteLine($"✅ [{ComponentId}:{callId}] HandleSaveDraft completed");
    }

    [JSInvokable] 
    public async Task HandleCommitChanges()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"🎯 [{ComponentId}:{callId}] HandleCommitChanges called from JavaScript");
        await CommitChanges();
        Console.WriteLine($"✅ [{ComponentId}:{callId}] HandleCommitChanges completed");
    }

    [JSInvokable]
    public async Task HandleInsertBold()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"🎯 [{ComponentId}:{callId}] HandleInsertBold called from JavaScript");
        await InsertBold();
        Console.WriteLine($"✅ [{ComponentId}:{callId}] HandleInsertBold completed");
    }

    // Collaboration methods
    private async Task InitializeCollaboration()
    {
        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            if (httpContext?.User?.Identity?.IsAuthenticated != true)
            {
                CollaborationStatus = "Not authenticated";
                CollaborationStatusClass = "bg-warning";
                StateHasChanged();
                return;
            }

            var baseUrl = await JS.InvokeAsync<string>("eval", "window.location.origin");
            
            _editHubConnection = new HubConnectionBuilder()
                .WithUrl($"{baseUrl}/editHub", options =>
                {
                    // Copy authentication cookies
                    var cookieHeader = httpContext.Request.Headers["Cookie"].ToString();
                    if (!string.IsNullOrEmpty(cookieHeader))
                    {
                        options.Headers["Cookie"] = cookieHeader;
                    }
                })
                .WithAutomaticReconnect()
                .Build();

            // Set up event handlers
            _editHubConnection.On<string, int>("DocumentState", OnDocumentState);
            _editHubConnection.On<TextOperation>("ReceiveOperation", OnReceiveOperation);
            _editHubConnection.On<CursorPosition>("ReceiveCursor", OnReceiveCursor);
            _editHubConnection.On<UserState>("UserJoined", OnUserJoined);
            _editHubConnection.On<string>("UserLeft", OnUserLeft);
            _editHubConnection.On<List<UserState>>("UserList", OnUserList);
            _editHubConnection.On<string, long>("OperationConfirmed", OnOperationConfirmed);
            _editHubConnection.On<string, string>("OperationRejected", OnOperationRejected);
            _editHubConnection.On<string>("Error", OnCollaborationError);

            _editHubConnection.Reconnecting += (exception) =>
            {
                CollaborationStatus = "Reconnecting...";
                CollaborationStatusClass = "bg-warning";
                InvokeAsync(StateHasChanged);
                return Task.CompletedTask;
            };

            _editHubConnection.Reconnected += (connectionId) =>
            {
                CollaborationStatus = "Online";
                CollaborationStatusClass = "bg-success";
                InvokeAsync(StateHasChanged);
                return Task.CompletedTask;
            };

            _editHubConnection.Closed += (exception) =>
            {
                CollaborationStatus = "Disconnected";
                CollaborationStatusClass = "bg-danger";
                ConnectedUsers.Clear();
                InvokeAsync(StateHasChanged);
                return Task.CompletedTask;
            };

            // Connect and join room
            CollaborationStatus = "Connecting...";
            CollaborationStatusClass = "bg-warning";
            StateHasChanged();

            await _editHubConnection.StartAsync();

            var userId = httpContext.User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? 
                        httpContext.User.FindFirst("sub")?.Value ?? 
                        Guid.NewGuid().ToString();

            await _editHubConnection.InvokeAsync("JoinEditRoom", PageId.ToString(), userId);

            IsCollaborationEnabled = true;
            CollaborationStatus = "Online";
            CollaborationStatusClass = "bg-success";

            // Start cursor broadcasting timer
            _cursorBroadcastTimer = new Timer(async _ => await BroadcastCursor(), null, 
                TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Collaboration initialization failed: {ex.Message}");
            CollaborationStatus = $"Failed: {ex.Message}";
            CollaborationStatusClass = "bg-danger";
            StateHasChanged();
        }
    }

    private async Task OnDocumentState(string content, int operationCounter)
    {
        try
        {
            _serverOperationCounter = operationCounter;
            await JS.InvokeVoidAsync("setEnhancedEditorContent", _editorId, content);
            Console.WriteLine($"✅ Document synchronized with {operationCounter} operations");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to sync document state: {ex.Message}");
        }
    }

    private async Task OnReceiveOperation(TextOperation operation)
    {
        try
        {
            // Apply operation to editor
            await ApplyOperationToEditor(operation);
            _serverOperationCounter++;
            Console.WriteLine($"✅ Applied remote operation: {operation.OpType} at {operation.Position}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to apply remote operation: {ex.Message}");
        }
    }

    private Task OnReceiveCursor(CursorPosition cursor)
    {
        try
        {
            // Ensure we have a valid component state
            if (string.IsNullOrEmpty(_editorId))
            {
                Console.WriteLine("❌ Editor not initialized for cursor update");
                return Task.CompletedTask;
            }

            // Find the user info to get color and display name
            var user = ConnectedUsers.FirstOrDefault(u => u.UserId == cursor.UserId);
            var userColor = user?.Color ?? "#6c757d";
            var displayName = user?.DisplayName ?? "Unknown User";
            
            // Call JavaScript directly without InvokeAsync to avoid cancellation
            _ = Task.Run(async () =>
            {
                try
                {
                    await JS.InvokeVoidAsync("updateRemoteCursor", _editorId, cursor.UserId, cursor.Start, cursor.End, userColor, displayName);
                    Console.WriteLine($"✅ [{_editorId}] Updated cursor for {displayName} at {cursor.Start}-{cursor.End}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"❌ [{_editorId}] Failed to update remote cursor for {displayName}: {ex.Message}");
                }
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Error in OnReceiveCursor: {ex.Message}");
        }
        
        return Task.CompletedTask;
    }

    private Task OnUserJoined(UserState user)
    {
        if (!ConnectedUsers.Any(u => u.UserId == user.UserId))
        {
            ConnectedUsers.Add(user);
            InvokeAsync(StateHasChanged);
            Console.WriteLine($"✅ User joined: {user.DisplayName}");
        }
        return Task.CompletedTask;
    }

    private Task OnUserLeft(string userId)
    {
        ConnectedUsers.RemoveAll(u => u.UserId == userId);
        InvokeAsync(async () =>
        {
            try
            {
                await JS.InvokeVoidAsync("removeRemoteCursor", _editorId, userId);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ [{_editorId}] Failed to remove remote cursor: {ex.Message}");
            }
        });
        Console.WriteLine($"✅ User left: {userId}");
        return Task.CompletedTask;
    }

    private Task OnUserList(List<UserState> users)
    {
        ConnectedUsers = users ?? new List<UserState>();
        InvokeAsync(StateHasChanged);
        Console.WriteLine($"✅ Updated user list: {ConnectedUsers.Count} users");
        return Task.CompletedTask;
    }

    private async Task OnOperationConfirmed(string operationId, long serverSequenceNumber)
    {
        // Remove confirmed operation from pending structures
        _pendingOperations = new Queue<TextOperation>(_pendingOperations.Where(op => op.OperationId != operationId));
        _pendingOperationMap.Remove(operationId);
        _operationContentBackup.Remove(operationId);
        
        // Update sequence number tracking
        _lastKnownSequenceNumber = Math.Max(_lastKnownSequenceNumber, serverSequenceNumber);
        
        // Update server with our latest state
        if (_editHubConnection?.State == HubConnectionState.Connected)
        {
            await _editHubConnection.InvokeAsync("UpdateClientState", PageId.ToString(), _lastKnownSequenceNumber);
        }
        
        Console.WriteLine($"✅ Operation confirmed: {operationId} (seq: {serverSequenceNumber})");
    }

    private async Task OnOperationRejected(string operationId, string reason)
    {
        Console.WriteLine($"❌ Operation rejected: {operationId} - {reason}");
        
        // Rollback the rejected operation
        if (_pendingOperationMap.TryGetValue(operationId, out var rejectedOperation) &&
            _operationContentBackup.TryGetValue(operationId, out var backupContent))
        {
            try
            {
                // Restore content from backup
                await JS.InvokeVoidAsync("setEnhancedEditorContent", _editorId, backupContent);
                Console.WriteLine($"🔄 Rolled back rejected operation: {operationId}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ Failed to rollback operation {operationId}: {ex.Message}");
                // Request document sync as fallback
                if (_editHubConnection?.State == HubConnectionState.Connected)
                {
                    await _editHubConnection.InvokeAsync("RequestDocumentSync", PageId.ToString());
                }
            }
        }
        
        // Clean up pending operation
        _pendingOperations = new Queue<TextOperation>(_pendingOperations.Where(op => op.OperationId != operationId));
        _pendingOperationMap.Remove(operationId);
        _operationContentBackup.Remove(operationId);
    }

    private Task OnCollaborationError(string error)
    {
        Console.WriteLine($"❌ Collaboration error: {error}");
        CollaborationStatus = $"Error: {error}";
        CollaborationStatusClass = "bg-danger";
        InvokeAsync(StateHasChanged);
        return Task.CompletedTask;
    }

    private async Task ApplyOperationToEditor(TextOperation operation)
    {
        switch (operation.OpType)
        {
            case TextOperation.OperationType.Insert:
                await JS.InvokeVoidAsync("applyInsertOperation", _editorId, operation.Position, operation.Content);
                break;
            case TextOperation.OperationType.Delete:
                await JS.InvokeVoidAsync("applyDeleteOperation", _editorId, operation.Position, operation.Length);
                break;
            case TextOperation.OperationType.Replace:
                await JS.InvokeVoidAsync("applyReplaceOperation", _editorId, operation.SelectionStart, operation.SelectionEnd, operation.Content ?? "");
                break;
        }
    }

    private async Task BroadcastCursor()
    {
        if (!IsCollaborationEnabled || _editHubConnection?.State != HubConnectionState.Connected)
            return;

        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            var userId = httpContext?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? 
                        httpContext?.User?.FindFirst("sub")?.Value ?? 
                        "";

            if (string.IsNullOrEmpty(userId)) return;

            var cursorInfo = await JS.InvokeAsync<int[]>("getEditorCursorPosition", _editorId);
            if (cursorInfo?.Length >= 2)
            {
                var currentStart = cursorInfo[0];
                var currentEnd = cursorInfo[1];
                
                // Only broadcast if cursor position has changed
                if (currentStart != _lastCursorStart || currentEnd != _lastCursorEnd)
                {
                    var cursor = new CursorPosition
                    {
                        UserId = userId,
                        Start = currentStart,
                        End = currentEnd
                    };

                    await _editHubConnection.InvokeAsync("SendCursorUpdate", PageId.ToString(), cursor);
                    
                    // Update last known position
                    _lastCursorStart = currentStart;
                    _lastCursorEnd = currentEnd;
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to broadcast cursor: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnTextChange(string newContent, int position, string changeType, string text)
    {
        if (!IsCollaborationEnabled || _editHubConnection?.State != HubConnectionState.Connected)
            return;

        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            var userId = httpContext?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? 
                        httpContext?.User?.FindFirst("sub")?.Value ?? 
                        Guid.NewGuid().ToString();

            TextOperation? operation = null;

            if (changeType == "insert")
            {
                operation = TextOperation.Insert(position, text, userId);
            }
            else if (changeType == "delete")
            {
                operation = TextOperation.Delete(position, text.Length, userId);
            }

            if (operation != null)
            {
                // Store content backup before sending operation for potential rollback
                var contentBeforeOperation = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
                _operationContentBackup[operation.OperationId] = contentBeforeOperation;
                _pendingOperationMap[operation.OperationId] = operation;
                
                _pendingOperations.Enqueue(operation);
                _localOperationCounter++;
                
                await _editHubConnection.InvokeAsync("SendTextOperation", PageId.ToString(), operation);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to send text operation: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnTextReplace(int selectionStart, int selectionEnd, string newText)
    {
        if (!IsCollaborationEnabled || _editHubConnection?.State != HubConnectionState.Connected)
            return;

        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            var userId = httpContext?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? 
                        httpContext?.User?.FindFirst("sub")?.Value ?? 
                        Guid.NewGuid().ToString();

            var operation = TextOperation.Replace(selectionStart, selectionEnd, newText, userId);
            
            // Store content backup before sending operation for potential rollback
            var contentBeforeOperation = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            _operationContentBackup[operation.OperationId] = contentBeforeOperation;
            _pendingOperationMap[operation.OperationId] = operation;
            
            _pendingOperations.Enqueue(operation);
            _localOperationCounter++;
            
            await _editHubConnection.InvokeAsync("SendTextOperation", PageId.ToString(), operation);
            
            Console.WriteLine($"✅ Sent replace operation: {selectionStart}-{selectionEnd} -> '{newText}'");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to send text replace operation: {ex.Message}");
        }
    }

}
