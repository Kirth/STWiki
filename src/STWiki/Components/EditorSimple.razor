@using Microsoft.JSInterop
@using System.Text.Json
@using System.Text
@using Microsoft.AspNetCore.SignalR.Client
@using STWiki.Models.Collaboration
@using System.Security.Claims
@using System.Security.Cryptography
@using STWiki.Services
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject HttpClient HttpClient
@inject IHttpContextAccessor HttpContextAccessor

<div class="editor-container" id="editor-container-@_editorId" data-editor-id="@_editorId" data-format="@BodyFormat">
    <!-- Hidden field for this editor instance -->
    <input type="hidden" name="Body" data-role="body" />
    <!-- Format badge for this editor -->
    <span data-role="format-badge" style="display: none;">@BodyFormat</span>
    
    <div class="editor-toolbar mb-2">
        <div class="d-flex justify-content-between align-items-center">
            <div class="btn-group btn-group-sm" role="group">
                <button type="button" class="btn btn-outline-secondary" disabled="@(!IsFullyReady)" data-action="save-draft">
                    Save Draft
                </button>
                <button type="button" class="btn btn-primary" disabled="@(!IsFullyReady)" data-action="commit-changes">
                    Commit Changes
                </button>
            </div>
            <div class="editor-status d-flex gap-2">
                @if (HasDraft && !IsNewPage)
                {
                    <span class="badge bg-info" title="This page has uncommitted draft content">
                        <i class="bi bi-pencil-square me-1"></i>Draft
                        @if (LastDraftAt.HasValue)
                        {
                            <small> (@LastDraftAt.Value.ToString("HH:mm"))</small>
                        }
                    </span>
                }
                @if (IsFullyReady)
                {
                    <span class="badge bg-success">Ready</span>
                }
                else if (IsReady && !IsBlazorConnected)
                {
                    <span class="badge bg-warning">Connecting...</span>
                }
                else
                {
                    <span class="badge bg-warning">Loading...</span>
                }
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header py-2">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">Editor</h6>
                        <div class="btn-group btn-group-sm" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" disabled="@(!IsFullyReady)" data-action="insert-bold" title="Bold (Ctrl+B)">
                                <strong>B</strong>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Italic (Ctrl+I)">
                                <em>I</em>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Inline Code">
                                <code>&lt;/&gt;</code>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Code Block">
                                <code>{ }</code>
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm ms-2" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 1">
                                H1
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 2">
                                H2
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 3">
                                H3
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm ms-2" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Unordered List">
                                List
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Ordered List">
                                1. List
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Blockquote">
                                Quote
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Link">
                                Link
                            </button>
                        </div>
                    </div>
                </div>
                <div class="card-body p-0" style="position: relative;">
                    <textarea id="@_editorId" 
                              class="form-control border-0" 
                              rows="20" 
                              placeholder="@(BodyFormat == "markdown" ? "Start writing your wiki content in Markdown..." : "Start writing your wiki content in HTML...")"
                              data-room="@_safeRoom"
                              data-role="editor"
                              style="resize: vertical; min-height: 400px; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 14px; line-height: 1.5;">@_safeContent</textarea>
                    <div id="remote-cursor-overlay-@_editorId" class="remote-cursor-overlay"></div>
                    
                    <!-- Drag and Drop Overlay -->
                    <div id="drag-drop-overlay-@_editorId" class="drag-drop-overlay d-none">
                        <div class="drag-drop-content">
                            <i class="bi bi-cloud-arrow-up display-1 text-primary"></i>
                            <h4 class="mt-3">Drop images here to upload</h4>
                            <p class="text-muted">Supported formats: JPG, PNG, GIF, WebP</p>
                        </div>
                    </div>
                </div>
                <div class="card-footer py-2">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">
                            <span data-role="word-count">0 words</span> | 
                            <span data-role="char-count">0 characters</span>
                        </small>
                        <small class="text-muted">
                            <span data-role="status">Ready</span>
                        </small>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-6">
            <div class="card">
                <div class="card-header py-2">
                    <h6 class="mb-0">Preview</h6>
                </div>
                <div class="card-body" style="min-height: 400px; max-height: 500px; overflow-y: auto;">
                    <div data-role="preview" class="markdown-content">
                        <em>Preview will appear here...</em>
                    </div>
                </div>
                <div class="card-footer py-2">
                    <small class="text-muted">
                        Collaboration: <span id="presence-status" class="badge @CollaborationStatusClass">@CollaborationStatus</span>
                        @if (ConnectedUsers.Any())
                        {
                            <div class="collaboration-users mt-2">
                                @foreach (var user in ConnectedUsers.Take(5))
                                {
                                    <span class="user-indicator me-1" style="background: @user.Color; color: white; border-radius: 50%; width: 24px; height: 24px; display: inline-flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold;" title="@user.DisplayName">
                                        @user.DisplayName.Substring(0, Math.Min(2, user.DisplayName.Length)).ToUpper()
                                    </span>
                                }
                                @if (ConnectedUsers.Count > 5)
                                {
                                    <span class="badge bg-secondary">+@(ConnectedUsers.Count - 5) more</span>
                                }
                            </div>
                        }
                    </small>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] 
    public string InitialContentRaw { get; set; } = "";
    
    [Parameter] 
    public string YjsRoomRaw { get; set; } = "";
    
    [Parameter] 
    public Guid PageId { get; set; }
    
    [Parameter]
    public string BodyFormat { get; set; } = "markdown";
    
    [Parameter]
    public bool EnableCollaboration { get; set; } = true;
    
    [Parameter]
    public bool HasDraft { get; set; }
    
    [Parameter]
    public DateTimeOffset? LastDraftAt { get; set; }
    
    [Parameter]
    public DateTimeOffset? LastCommittedAt { get; set; }
    
    // Safe versions for DOM use
    private string _editorId = $"simple-editor-{Guid.NewGuid():N}";
    private string _safeRoom = "";
    private string _safeContent = "";
    
    private bool IsReady = false;
    private bool IsBlazorConnected = false;
    private bool IsFullyReady => IsReady && IsBlazorConnected;
    private bool IsNewPage => PageId == Guid.Empty;
    private Timer? AutosaveTimer = null;
    
    // Collaboration properties
    private HubConnection? _editHubConnection;
    private Timer? _cursorBroadcastTimer;
    private Timer? _stateSyncTimer;
    private List<UserState> ConnectedUsers = new();
    private string CollaborationStatus = "Offline";
    private string CollaborationStatusClass = "bg-secondary";
    private bool IsCollaborationEnabled = false;
    
    // Cursor state tracking
    private int _lastCursorStart = -1;
    private int _lastCursorEnd = -1;
    private Queue<TextOperation> _pendingOperations = new();
    
    // Enhanced state tracking for race condition prevention
    private long _lastKnownSequenceNumber = 0;
    private readonly Dictionary<string, TextOperation> _pendingOperationMap = new();
    private readonly Dictionary<string, string> _operationContentBackup = new();
    private int _localOperationCounter = 0;
    private int _serverOperationCounter = 0;
    private bool _isProcessingOperation = false;
    
    // Unique component instance ID for debugging
    private readonly string ComponentId = Guid.NewGuid().ToString("N")[..8];
    private int RenderCount = 0;
    private int MethodCallCount = 0;

    protected override void OnInitialized()
    {
        // Sanitize inputs during initialization
        _safeContent = StripFormatChars(InitialContentRaw);
        _safeRoom = SafeDomToken(YjsRoomRaw);
        
        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        // Re-sanitize inputs when parameters change
        _safeContent = StripFormatChars(InitialContentRaw);
        _safeRoom = SafeDomToken(YjsRoomRaw);
        
        base.OnParametersSet();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"🚀 OnAfterRenderAsync called - firstRender: {firstRender}, PageId: {PageId}");
        if (firstRender)
        {
            try
            {
                Console.WriteLine($"🔧 Starting first render initialization for page {PageId}");
                // Wait a bit to ensure Blazor is fully loaded
                await Task.Delay(100);
                
                // Check Blazor connection state
                try 
                {
                    IsBlazorConnected = await JS.InvokeAsync<bool>("checkBlazorConnection");
                }
                catch
                {
                    IsBlazorConnected = false;
                }
                
                // Re-render with connection state
                if (IsBlazorConnected)
                {
                    StateHasChanged();
                    await Task.Delay(50);
                }
                
                // Create .NET object reference and initialize NEW modular editor
                var objRef = DotNetObjectReference.Create(this);
                var success = await JS.InvokeAsync<bool>("initWikiEditor", $"editor-container-{_editorId}", _safeContent, BodyFormat, objRef);
                Console.WriteLine($"📝 NEW Editor initialization success: {success} for page {PageId}");
                
                if (success)
                {
                    Console.WriteLine($"✅ Editor ready, checking collaboration setup for page {PageId}");
                    IsReady = true;
                    
                    // Initialize collaboration if enabled
                    Console.WriteLine($"🔍 Collaboration check: EnableCollaboration={EnableCollaboration}, IsNewPage={IsNewPage}, PageId={PageId}");
                    if (EnableCollaboration && !IsNewPage)
                    {
                        Console.WriteLine($"✅ Starting collaboration initialization for page {PageId}");
                        await InitializeCollaboration();
                    }
                    else
                    {
                        Console.WriteLine($"❌ Collaboration NOT initialized. EnableCollaboration={EnableCollaboration}, IsNewPage={IsNewPage}, PageId={PageId}");
                    }
                    
                    // Start autosave timer for existing pages
                    if (!IsNewPage)
                    {
                        AutosaveTimer = new Timer(async _ => await AutoSave(), null, 
                            TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(30));
                    }
                }
                
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ EditorSimple initialization failed for page {PageId}: {ex.Message}");
                Console.WriteLine($"❌ Exception details: {ex}");
                IsReady = false;
                IsBlazorConnected = false;
                StateHasChanged();
            }
        }
    }

    private async Task SaveDraft()
    {
        if (!IsFullyReady || IsNewPage) 
        {
            await JS.InvokeVoidAsync("showEditorStatus", "Save not available for new pages");
            return;
        }
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            var request = new { Content = content };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/autosave", httpContent);
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Draft saved");
                }
                catch
                {
                    await JS.InvokeVoidAsync("showEditorStatus", "Save failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                await JS.InvokeVoidAsync("showEditorStatus", "Save failed - authentication required");
            }
            else
            {
                await JS.InvokeVoidAsync("showEditorStatus", $"Save failed: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ SaveDraft failed: {ex.Message}");
            await JS.InvokeVoidAsync("showEditorStatus", $"Save failed: {ex.Message}");
        }
    }

    private async Task CommitChanges()
    {
        if (!IsFullyReady || IsNewPage) 
        {
            await JS.InvokeVoidAsync("showEditorStatus", "Use the main Save button to create new pages");
            return;
        }
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            var request = new { Content = content, Summary = "Updated via enhanced editor" };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/commit", httpContent);
            var responseContent = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"CommitChanges() response status: {response.StatusCode}");
            Console.WriteLine($"CommitChanges() response content: {responseContent}");
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Changes committed successfully");
                    // Notify that changes have been committed via API
                    await JS.InvokeVoidAsync("markContentAsCommitted");
                }
                catch
                {
                    // Not JSON, probably HTML - treat as error even with 200 status
                    await JS.InvokeVoidAsync("showEditorStatus", "Commit failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                await JS.InvokeVoidAsync("showEditorStatus", "Commit failed - authentication required. Please refresh and log in again.");
            }
            else
            {
                await JS.InvokeVoidAsync("showEditorStatus", $"Commit failed: {response.StatusCode} - {responseContent}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ CommitChanges failed: {ex.Message}");
            await JS.InvokeVoidAsync("showEditorStatus", $"Commit failed: {ex.Message}");
        }
    }

    private async Task AutoSave()
    {
        if (!IsReady || IsNewPage) return;
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            if (string.IsNullOrEmpty(content))
            {
                Console.WriteLine("Autosave skipped - no content");
                return;
            }
            
            // If collaboration is active, get the authoritative content from the session
            if (IsCollaborationEnabled && _editHubConnection?.State == HubConnectionState.Connected)
            {
                try
                {
                    // Request latest document state to ensure we're saving the most current version
                    await _editHubConnection.InvokeAsync("RequestDocumentSync", PageId.ToString());
                    
                    // Wait a moment for sync, then get content again
                    await Task.Delay(100);
                    content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Failed to sync before autosave: {ex.Message}");
                    // Continue with current content
                }
            }
            
            var request = new { Content = content };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/autosave", httpContent);
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    var statusMessage = IsCollaborationEnabled ? "Auto-saved (collaborative)" : "Auto-saved";
                    await JS.InvokeVoidAsync("showEditorStatus", statusMessage);
                }
                catch
                {
                    Console.WriteLine("Autosave failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                Console.WriteLine("Autosave failed - authentication required");
            }
            else
            {
                Console.WriteLine($"Autosave failed with status: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Autosave error: {ex.Message}");
        }
    }

    public async ValueTask DisposeAsync()
    {
        AutosaveTimer?.Dispose();
        _cursorBroadcastTimer?.Dispose();
        _stateSyncTimer?.Dispose();
        
        try
        {
            if (_editHubConnection != null)
            {
                await _editHubConnection.StopAsync();
                await _editHubConnection.DisposeAsync();
            }
            
            if (IsReady)
            {
                await JS.InvokeVoidAsync("destroyEnhancedEditor", _editorId);
            }
        }
        catch
        {
            // Best effort cleanup
        }
    }

    // Helper method to make authenticated HTTP requests with cookies
    private async Task<HttpResponseMessage> MakeAuthenticatedRequest(string url, HttpContent content)
    {
        var httpContext = HttpContextAccessor.HttpContext;
        if (httpContext == null)
        {
            // Fallback to regular HttpClient if no context available
            return await HttpClient.PostAsync(url, content);
        }

        // Create a new HttpClient that includes authentication cookies
        var handler = new HttpClientHandler()
        {
            UseCookies = true
        };

        using var authenticatedClient = new HttpClient(handler);
        
        // Set base URL
        var baseUrl = await JS.InvokeAsync<string>("eval", "window.location.origin");
        authenticatedClient.BaseAddress = new Uri(baseUrl);
        
        // Copy authentication cookies from current request
        var cookieHeader = httpContext.Request.Headers["Cookie"].ToString();
        if (!string.IsNullOrEmpty(cookieHeader))
        {
            authenticatedClient.DefaultRequestHeaders.Add("Cookie", cookieHeader);
        }
        
        // Copy authorization headers if present
        if (httpContext.Request.Headers.ContainsKey("Authorization"))
        {
            var authHeader = httpContext.Request.Headers["Authorization"].ToString();
            authenticatedClient.DefaultRequestHeaders.Add("Authorization", authHeader);
        }
        
        return await authenticatedClient.PostAsync(url, content);
    }

    private async Task InsertMarkdown(string before, string after)
    {
        try
        {
            await JS.InvokeVoidAsync("insertMarkdown", before, after);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error inserting markdown: {ex.Message}");
        }
    }


    // Individual button handlers
    private async Task InsertBold() => await InsertMarkdown("**", "**");
    private async Task InsertItalic() => await InsertMarkdown("*", "*");

    private async Task InsertInlineCode() => await InsertMarkdown("`", "`");
    private async Task InsertCodeBlock() => await InsertMarkdown("```\n", "\n```");
    private async Task InsertHeader1() => await InsertMarkdown("# ", "");
    private async Task InsertHeader2() => await InsertMarkdown("## ", "");
    private async Task InsertHeader3() => await InsertMarkdown("### ", "");
    private async Task InsertList() => await InsertMarkdown("- ", "");
    private async Task InsertOrderedList() => await InsertMarkdown("1. ", "");
    private async Task InsertBlockquote() => await InsertMarkdown("> ", "");
    private async Task InsertLink() => await InsertMarkdown("[", "](url)");
    
    /// <summary>
    /// Remove BOM and other format characters that can cause DOM InvalidCharacterError
    /// </summary>
    static string StripFormatChars(string s)
    {
        if (string.IsNullOrEmpty(s)) return string.Empty;
        
        // More aggressive BOM and format character removal
        var cleaned = s;
        
        // Remove BOM variants
        cleaned = cleaned.Replace("\uFEFF", ""); // UTF-8 BOM
        cleaned = cleaned.Replace("\uFFFE", ""); // UTF-16 BOM
        cleaned = cleaned.Replace("\u0000FEFF", ""); // Alternative BOM representation
        
        // Remove zero-width characters
        cleaned = cleaned.Replace("\u200B", ""); // Zero Width Space
        cleaned = cleaned.Replace("\u200C", ""); // Zero Width Non-Joiner  
        cleaned = cleaned.Replace("\u200D", ""); // Zero Width Joiner
        cleaned = cleaned.Replace("\u2060", ""); // Word Joiner
        cleaned = cleaned.Replace("\u180E", ""); // Mongolian Vowel Separator
        
        // Keep only printable characters + tab/newline/carriage return
        cleaned = new string(cleaned.Where(c => c >= ' ' || c is '\t' or '\n' or '\r').ToArray());
        
        return cleaned;
    }

    /// <summary>
    /// Create DOM-safe token from user input (for IDs, classes, attribute names)
    /// </summary>
    static string SafeDomToken(string s)
    {
        s = StripFormatChars(s ?? "");
        s = System.Text.RegularExpressions.Regex.Replace(s, @"[^\w\-]", ""); // only [A-Za-z0-9_-]
        return string.IsNullOrEmpty(s) ? "room" : s;
    }

    // JavaScript-invokable methods for button actions
    [JSInvokable]
    public async Task HandleSaveDraft()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"🎯 [{ComponentId}:{callId}] HandleSaveDraft called from JavaScript");
        await SaveDraft();
        Console.WriteLine($"✅ [{ComponentId}:{callId}] HandleSaveDraft completed");
    }

    [JSInvokable] 
    public async Task HandleCommitChanges()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"🎯 [{ComponentId}:{callId}] HandleCommitChanges called from JavaScript");
        await CommitChanges();
        Console.WriteLine($"✅ [{ComponentId}:{callId}] HandleCommitChanges completed");
    }

    [JSInvokable]
    public async Task HandleInsertBold()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"🎯 [{ComponentId}:{callId}] HandleInsertBold called from JavaScript");
        await InsertBold();
        Console.WriteLine($"✅ [{ComponentId}:{callId}] HandleInsertBold completed");
    }

    // Collaboration methods
    private async Task InitializeCollaboration()
    {
        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            if (httpContext?.User?.Identity?.IsAuthenticated != true)
            {
                CollaborationStatus = "Not authenticated";
                CollaborationStatusClass = "bg-warning";
                StateHasChanged();
                return;
            }

            var baseUrl = await JS.InvokeAsync<string>("eval", "window.location.origin");
            
            _editHubConnection = new HubConnectionBuilder()
                .WithUrl($"{baseUrl}/editHub", options =>
                {
                    // Copy authentication cookies
                    var cookieHeader = httpContext.Request.Headers["Cookie"].ToString();
                    if (!string.IsNullOrEmpty(cookieHeader))
                    {
                        options.Headers["Cookie"] = cookieHeader;
                    }
                })
                .WithAutomaticReconnect()
                .Build();

            // Set up event handlers with detailed logging
            Console.WriteLine($"🔗 Registering SignalR event handlers for page {PageId}...");
            _editHubConnection.On<string, int>("DocumentState", OnDocumentState);
            Console.WriteLine($"✅ Registered DocumentState handler");
            
            _editHubConnection.On<TextOperation>("ReceiveOperation", OnReceiveOperation);
            Console.WriteLine($"✅ Registered ReceiveOperation handler - THIS IS THE CRITICAL ONE");
            
            _editHubConnection.On<CursorPosition>("ReceiveCursor", OnReceiveCursor);
            Console.WriteLine($"✅ Registered ReceiveCursor handler");
            
            _editHubConnection.On<UserState>("UserJoined", OnUserJoined);
            _editHubConnection.On<string>("UserLeft", OnUserLeft);
            _editHubConnection.On<List<UserState>>("UserList", OnUserList);
            _editHubConnection.On<string, long>("OperationConfirmed", OnOperationConfirmed);
            _editHubConnection.On<string, string>("OperationRejected", OnOperationRejected);
            _editHubConnection.On<string>("Error", OnCollaborationError);
            
            // Phase 1: State synchronization event handlers
            _editHubConnection.On<long>("StateVerified", OnStateVerified);
            _editHubConnection.On<string, long, string>("RequiredResync", OnRequiredResync);
            Console.WriteLine($"✅ All event handlers registered for page {PageId}");

            _editHubConnection.Reconnecting += (exception) =>
            {
                Console.WriteLine($"🔄 SignalR Reconnecting for page {PageId}. Exception: {exception?.Message}");
                CollaborationStatus = "Reconnecting...";
                CollaborationStatusClass = "bg-warning";
                InvokeAsync(StateHasChanged);
                return Task.CompletedTask;
            };

            _editHubConnection.Reconnected += (connectionId) =>
            {
                Console.WriteLine($"✅ SignalR Reconnected for page {PageId}. Connection ID: {connectionId}");
                CollaborationStatus = "Online";
                CollaborationStatusClass = "bg-success";
                InvokeAsync(StateHasChanged);
                return Task.CompletedTask;
            };

            _editHubConnection.Closed += (exception) =>
            {
                Console.WriteLine($"❌ SignalR Connection Closed for page {PageId}. Exception: {exception?.Message}");
                CollaborationStatus = "Disconnected";
                CollaborationStatusClass = "bg-danger";
                ConnectedUsers.Clear();
                InvokeAsync(StateHasChanged);
                return Task.CompletedTask;
            };

            // Connect and join room
            Console.WriteLine($"🚀 Starting SignalR connection for page {PageId}...");
            CollaborationStatus = "Connecting...";
            CollaborationStatusClass = "bg-warning";
            StateHasChanged();

            await _editHubConnection.StartAsync();
            Console.WriteLine($"✅ SignalR connection started. State: {_editHubConnection.State}, Connection ID: {_editHubConnection.ConnectionId}");

            var userId = httpContext.User.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? 
                        httpContext.User.FindFirst("sub")?.Value ?? 
                        Guid.NewGuid().ToString();
            Console.WriteLine($"👤 Using userId: {userId}");

            Console.WriteLine($"🏠 Joining edit room for page {PageId}...");
            await _editHubConnection.InvokeAsync("JoinEditRoom", PageId.ToString(), userId);
            Console.WriteLine($"✅ Successfully joined edit room for page {PageId}");

            IsCollaborationEnabled = true;
            CollaborationStatus = "Online";
            CollaborationStatusClass = "bg-success";
            Console.WriteLine($"🎉 Collaboration fully enabled for page {PageId}");

            // Start cursor broadcasting timer
            _cursorBroadcastTimer = new Timer(async _ => await BroadcastCursor(), null, 
                TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));

            // Phase 1: Start periodic state sync timer (every 30 seconds, with initial delay of 10 seconds)
            _stateSyncTimer = new Timer(async _ => await PerformStateSync(), null, 
                TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(30));
            Console.WriteLine($"✅ State sync timer started for page {PageId} - first sync in 10 seconds");
            
            // Immediate test sync after a short delay
            _ = Task.Run(async () =>
            {
                await Task.Delay(2000); // Wait 2 seconds for initialization to complete
                Console.WriteLine($"🧪 Running initial test sync for page {PageId}");
                await PerformStateSync();
            });

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Collaboration initialization failed: {ex.Message}");
            CollaborationStatus = $"Failed: {ex.Message}";
            CollaborationStatusClass = "bg-danger";
            StateHasChanged();
        }
    }

    private async Task OnDocumentState(string content, int operationCounter)
    {
        try
        {
            _serverOperationCounter = operationCounter;
            await JS.InvokeVoidAsync("setEnhancedEditorContent", _editorId, content);
            Console.WriteLine($"✅ Document synchronized with {operationCounter} operations");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to sync document state: {ex.Message}");
        }
    }

    private async Task OnReceiveOperation(TextOperation operation)
    {
        try
        {
            _isProcessingOperation = true; // Prevent cursor broadcasting during operation processing
            
            Console.WriteLine($"🚨🚨🚨 CRITICAL: OnReceiveOperation C# METHOD CALLED! 🚨🚨🚨");
            Console.WriteLine($"📥 Page {PageId}: C# OnReceiveOperation handler invoked");
            
            // Get current editor content for debugging
            var currentContent = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            Console.WriteLine($"🔄 RECEIVING remote operation from user {operation.UserId}:");
            Console.WriteLine($"   Type: {operation.OpType}, Position: {operation.Position}, Length: {operation.Length}");
            Console.WriteLine($"   Content: '{operation.Content}', Server Seq: {operation.ServerSequenceNumber}");
            Console.WriteLine($"   Current editor length: {currentContent?.Length}, Pending ops: {_pendingOperations.Count}");
            
            // Check if we have pending operations that might conflict
            if (_pendingOperations.Count > 0)
            {
                Console.WriteLine($"⚠️  WARNING: Applying remote op while {_pendingOperations.Count} local ops are pending!");
                var pendingOps = _pendingOperations.ToArray();
                for (int i = 0; i < pendingOps.Length; i++)
                {
                    var pending = pendingOps[i];
                    Console.WriteLine($"     Pending {i}: {pending.OpType} at {pending.Position} ('{pending.Content}')");
                }
                
                // CRITICAL FIX: Transform remote operation against pending local operations
                var transformedOperation = TransformRemoteOperationAgainstPendingOps(operation, pendingOps);
                if (transformedOperation != null)
                {
                    Console.WriteLine($"🔄 Transformed remote op: {transformedOperation.OpType} at {transformedOperation.Position}");
                    operation = transformedOperation;
                }
                else
                {
                    Console.WriteLine($"❌ Remote operation cancelled due to conflicts");
                    return; // Skip this operation
                }
            }

            // Apply operation to editor
            await ApplyOperationToEditor(operation);
            _serverOperationCounter++;
            
            // Get content after applying operation
            var newContent = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            Console.WriteLine($"✅ Applied remote operation successfully. New editor length: {newContent?.Length}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to apply remote operation: {ex.Message}");
            Console.WriteLine($"   Stack trace: {ex.StackTrace}");
        }
        finally
        {
            _isProcessingOperation = false; // Re-enable cursor broadcasting
        }
    }
    
    /// <summary>
    /// Transform a remote operation against pending local operations to prevent conflicts
    /// </summary>
    private TextOperation? TransformRemoteOperationAgainstPendingOps(TextOperation remoteOp, TextOperation[] pendingOps)
    {
        var transformedOp = new TextOperation
        {
            OpType = remoteOp.OpType,
            Position = remoteOp.Position,
            Content = remoteOp.Content,
            Length = remoteOp.Length,
            UserId = remoteOp.UserId,
            Timestamp = remoteOp.Timestamp,
            OperationId = remoteOp.OperationId,
            ServerSequenceNumber = remoteOp.ServerSequenceNumber,
            SelectionStart = remoteOp.SelectionStart,
            SelectionEnd = remoteOp.SelectionEnd
        };
        
        foreach (var pendingOp in pendingOps)
        {
            // Transform against each pending operation  
            var previousOp = transformedOp;
            transformedOp = OperationalTransform.Transform(transformedOp, pendingOp);
            
            Console.WriteLine($"🔄 Transforming remote op {previousOp.OpType}@{previousOp.Position} against pending {pendingOp.OpType}@{pendingOp.Position} -> {transformedOp.OpType}@{transformedOp.Position}");
            
            // Check if operation is still valid after transformation
            if (!IsOperationValid(transformedOp))
            {
                Console.WriteLine($"❌ Remote operation became invalid after transformation against {pendingOp.OpType}");
                return null;
            }
        }
        
        return transformedOp;
    }
    
    /// <summary>
    /// Check if an operation is valid and attempt recovery if possible
    /// </summary>
    private bool IsOperationValid(TextOperation operation)
    {
        if (operation.Position < 0) 
        {
            Console.WriteLine($"❌ Invalid operation: negative position {operation.Position}");
            return false;
        }
        
        switch (operation.OpType)
        {
            case TextOperation.OperationType.Insert:
                var isValidInsert = !string.IsNullOrEmpty(operation.Content) && operation.Length == operation.Content.Length;
                if (!isValidInsert)
                {
                    Console.WriteLine($"❌ Invalid insert operation: Content='{operation.Content}', Length={operation.Length}");
                }
                return isValidInsert;
                
            case TextOperation.OperationType.Delete:
                var isValidDelete = operation.Length > 0;
                if (!isValidDelete)
                {
                    Console.WriteLine($"❌ Invalid delete operation: Length={operation.Length}");
                }
                return isValidDelete;
                
            case TextOperation.OperationType.Replace:
                return ValidateAndRecoverReplaceOperation(operation);
                
            default:
                return true;
        }
    }
    
    /// <summary>
    /// Validate Replace operation and attempt to recover from common issues
    /// </summary>
    private bool ValidateAndRecoverReplaceOperation(TextOperation operation)
    {
        // Check selection bounds
        if (operation.SelectionStart < 0 || operation.SelectionEnd < operation.SelectionStart)
        {
            Console.WriteLine($"❌ Invalid replace operation: bad selection bounds {operation.SelectionStart}-{operation.SelectionEnd}");
            return false;
        }
        
        // Check for malformed operation (empty selection with empty content - no-op)
        if (operation.SelectionStart == operation.SelectionEnd && string.IsNullOrEmpty(operation.Content))
        {
            Console.WriteLine($"⚠️ Replace operation is effectively a no-op: empty selection and empty content");
            return false; // Skip this operation
        }
        
        // Content length validation and recovery
        if (operation.Content != null && operation.Length != operation.Content.Length)
        {
            Console.WriteLine($"⚠️ Replace operation content length mismatch. Fixing: Length: {operation.Length} -> {operation.Content.Length}");
            operation.Length = operation.Content.Length; // Auto-fix this common issue
        }
        
        // Validate Position matches SelectionStart for Replace operations  
        if (operation.Position != operation.SelectionStart)
        {
            Console.WriteLine($"⚠️ Replace operation position mismatch. Fixing: Position: {operation.Position} -> {operation.SelectionStart}");
            operation.Position = operation.SelectionStart; // Auto-fix this common issue
        }
        
        return true;
    }

    private Task OnReceiveCursor(CursorPosition cursor)
    {
        try
        {
            // Ensure we have a valid component state
            if (string.IsNullOrEmpty(_editorId))
            {
                Console.WriteLine("❌ Editor not initialized for cursor update");
                return Task.CompletedTask;
            }

            // Find the user info to get color and display name
            var user = ConnectedUsers.FirstOrDefault(u => u.UserId == cursor.UserId);
            var userColor = user?.Color ?? "#6c757d";
            var displayName = user?.DisplayName ?? "Unknown User";
            
            // Call JavaScript directly without InvokeAsync to avoid cancellation
            _ = Task.Run(async () =>
            {
                try
                {
                    await JS.InvokeVoidAsync("updateRemoteCursor", _editorId, cursor.UserId, cursor.Start, cursor.End, userColor, displayName);
                    Console.WriteLine($"✅ [{_editorId}] Updated cursor for {displayName} at {cursor.Start}-{cursor.End}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"❌ [{_editorId}] Failed to update remote cursor for {displayName}: {ex.Message}");
                }
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Error in OnReceiveCursor: {ex.Message}");
        }
        
        return Task.CompletedTask;
    }

    private Task OnUserJoined(UserState user)
    {
        if (!ConnectedUsers.Any(u => u.UserId == user.UserId))
        {
            ConnectedUsers.Add(user);
            InvokeAsync(StateHasChanged);
            Console.WriteLine($"✅ User joined: {user.DisplayName}");
        }
        return Task.CompletedTask;
    }

    private Task OnUserLeft(string userId)
    {
        ConnectedUsers.RemoveAll(u => u.UserId == userId);
        InvokeAsync(async () =>
        {
            try
            {
                await JS.InvokeVoidAsync("removeRemoteCursor", _editorId, userId);
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ [{_editorId}] Failed to remove remote cursor: {ex.Message}");
            }
        });
        Console.WriteLine($"✅ User left: {userId}");
        return Task.CompletedTask;
    }

    private Task OnUserList(List<UserState> users)
    {
        ConnectedUsers = users ?? new List<UserState>();
        InvokeAsync(StateHasChanged);
        Console.WriteLine($"✅ Updated user list: {ConnectedUsers.Count} users");
        return Task.CompletedTask;
    }

    private async Task OnOperationConfirmed(string operationId, long serverSequenceNumber)
    {
        // Get operation details before removing
        var confirmedOp = _pendingOperationMap.GetValueOrDefault(operationId);
        var pendingCount = _pendingOperations.Count;
        
        // Remove confirmed operation from pending structures
        _pendingOperations = new Queue<TextOperation>(_pendingOperations.Where(op => op.OperationId != operationId));
        _pendingOperationMap.Remove(operationId);
        _operationContentBackup.Remove(operationId);
        
        // Update sequence number tracking
        _lastKnownSequenceNumber = Math.Max(_lastKnownSequenceNumber, serverSequenceNumber);
        
        // Update server with our latest state
        if (_editHubConnection?.State == HubConnectionState.Connected)
        {
            await _editHubConnection.InvokeAsync("UpdateClientState", PageId.ToString(), _lastKnownSequenceNumber);
        }
        
        Console.WriteLine($"✅ Operation confirmed: {operationId} (seq: {serverSequenceNumber})");
        Console.WriteLine($"   Confirmed op: {confirmedOp?.OpType} at {confirmedOp?.Position}");
        Console.WriteLine($"   Pending ops reduced from {pendingCount} to {_pendingOperations.Count}");
    }

    private async Task OnOperationRejected(string operationId, string reason)
    {
        Console.WriteLine($"❌ Operation rejected: {operationId} - {reason}");
        
        // Get the rejected operation for potential retry
        if (!_pendingOperationMap.TryGetValue(operationId, out var rejectedOperation))
        {
            Console.WriteLine($"⚠️ Cannot find rejected operation {operationId} for retry analysis");
            return;
        }
        
        // Analyze rejection reason and determine if retry is appropriate
        var shouldRetry = ShouldRetryOperation(rejectedOperation, reason);
        
        if (shouldRetry && rejectedOperation.RetryCount < 3) // Max 3 retries
        {
            Console.WriteLine($"🔄 Attempting retry #{rejectedOperation.RetryCount + 1} for operation {operationId}");
            
            try
            {
                // Get current content to re-validate operation
                var currentContent = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
                
                // Check if operation is still applicable after server changes
                if (IsOperationApplicable(rejectedOperation, currentContent))
                {
                    // Create retry operation with new ID and timestamp
                    var retryOperation = new TextOperation
                    {
                        OpType = rejectedOperation.OpType,
                        Position = rejectedOperation.Position,
                        Content = rejectedOperation.Content,
                        Length = rejectedOperation.Length,
                        UserId = rejectedOperation.UserId,
                        Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(),
                        SelectionStart = rejectedOperation.SelectionStart,
                        SelectionEnd = rejectedOperation.SelectionEnd,
                        OperationId = Guid.NewGuid().ToString(),
                        RetryCount = rejectedOperation.RetryCount + 1
                    };
                    
                    // Store backup and tracking for retry
                    _operationContentBackup[retryOperation.OperationId] = currentContent;
                    _pendingOperationMap[retryOperation.OperationId] = retryOperation;
                    _pendingOperations.Enqueue(retryOperation);
                    
                    // Send retry to server
                    await _editHubConnection.InvokeAsync("SendTextOperation", PageId.ToString(), retryOperation);
                    Console.WriteLine($"✅ Retry operation sent: {retryOperation.OperationId}");
                }
                else
                {
                    Console.WriteLine($"⚠️ Operation no longer applicable for retry, rolling back");
                    await RollbackOperation(operationId, rejectedOperation);
                }
            }
            catch (Exception retryEx)
            {
                Console.WriteLine($"❌ Failed to retry operation {operationId}: {retryEx.Message}");
                await RollbackOperation(operationId, rejectedOperation);
            }
        }
        else
        {
            if (!shouldRetry)
            {
                Console.WriteLine($"⚠️ Operation {operationId} not suitable for retry: {reason}");
            }
            else
            {
                Console.WriteLine($"⚠️ Max retry attempts exceeded for operation {operationId}");
            }
            
            await RollbackOperation(operationId, rejectedOperation);
        }
        
        // Clean up original operation
        _pendingOperations = new Queue<TextOperation>(_pendingOperations.Where(op => op.OperationId != operationId));
        _pendingOperationMap.Remove(operationId);
        _operationContentBackup.Remove(operationId);
    }
    
    /// <summary>
    /// Determine if an operation should be retried based on rejection reason
    /// </summary>
    private bool ShouldRetryOperation(TextOperation operation, string reason)
    {
        var reasonLower = reason.ToLower();
        
        // Retry for temporary/recoverable errors
        if (reasonLower.Contains("sequence") || 
            reasonLower.Contains("stale") || 
            reasonLower.Contains("conflict") ||
            reasonLower.Contains("race") ||
            reasonLower.Contains("timeout"))
        {
            return true;
        }
        
        // Don't retry for validation errors or permanent failures
        if (reasonLower.Contains("invalid") ||
            reasonLower.Contains("malformed") ||
            reasonLower.Contains("permission") ||
            reasonLower.Contains("unauthorized"))
        {
            return false;
        }
        
        // Default to retry for Replace operations (they're more prone to conflicts)
        return operation.OpType == TextOperation.OperationType.Replace;
    }
    
    /// <summary>
    /// Roll back a rejected operation to its previous state
    /// </summary>
    private async Task RollbackOperation(string operationId, TextOperation rejectedOperation)
    {
        if (_operationContentBackup.TryGetValue(operationId, out var backupContent))
        {
            try
            {
                // Restore content from backup
                await JS.InvokeVoidAsync("setEnhancedEditorContent", _editorId, backupContent);
                Console.WriteLine($"🔄 Rolled back rejected operation: {operationId}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"❌ Failed to rollback operation {operationId}: {ex.Message}");
                // Request document sync as fallback
                if (_editHubConnection?.State == HubConnectionState.Connected)
                {
                    Console.WriteLine($"🔄 Requesting document sync as rollback fallback");
                    await _editHubConnection.InvokeAsync("RequestDocumentSync", PageId.ToString());
                }
            }
        }
        else
        {
            Console.WriteLine($"⚠️ No backup content found for rollback of operation {operationId}");
        }
    }

    private Task OnCollaborationError(string error)
    {
        Console.WriteLine($"❌ Collaboration error: {error}");
        CollaborationStatus = $"Error: {error}";
        CollaborationStatusClass = "bg-danger";
        InvokeAsync(StateHasChanged);
        return Task.CompletedTask;
    }

    private async Task ApplyOperationToEditor(TextOperation operation)
    {
        try
        {
            // Get current content to validate bounds before applying operation
            var currentContent = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            if (currentContent == null)
            {
                Console.WriteLine($"❌ Cannot apply operation: current content is null");
                return;
            }
            
            Console.WriteLine($"📝 Applying {operation.OpType} operation to content (length: {currentContent.Length})");
            
            switch (operation.OpType)
            {
                case TextOperation.OperationType.Insert:
                    if (ValidateInsertOperation(operation, currentContent))
                    {
                        await JS.InvokeVoidAsync("applyInsertOperation", _editorId, operation.Position, operation.Content);
                        Console.WriteLine($"✅ Applied insert at position {operation.Position}: '{operation.Content}'");
                    }
                    break;
                    
                case TextOperation.OperationType.Delete:
                    if (ValidateDeleteOperation(operation, currentContent))
                    {
                        await JS.InvokeVoidAsync("applyDeleteOperation", _editorId, operation.Position, operation.Length);
                        Console.WriteLine($"✅ Applied delete at position {operation.Position}, length {operation.Length}");
                    }
                    break;
                    
                case TextOperation.OperationType.Replace:
                    if (ValidateReplaceOperationForApplication(operation, currentContent))
                    {
                        await JS.InvokeVoidAsync("applyReplaceOperation", _editorId, operation.SelectionStart, operation.SelectionEnd, operation.Content ?? "");
                        Console.WriteLine($"✅ Applied replace at {operation.SelectionStart}-{operation.SelectionEnd}: '{operation.Content}'");
                    }
                    break;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to apply {operation.OpType} operation: {ex.Message}");
            Console.WriteLine($"   Operation details: Pos={operation.Position}, Len={operation.Length}, Content='{operation.Content}'");
            throw; // Re-throw so the calling code can handle the failure
        }
    }
    
    /// <summary>
    /// Validate insert operation bounds before application
    /// </summary>
    private bool ValidateInsertOperation(TextOperation operation, string currentContent)
    {
        if (operation.Position < 0 || operation.Position > currentContent.Length)
        {
            Console.WriteLine($"❌ Insert operation position {operation.Position} is out of bounds (content length: {currentContent.Length})");
            return false;
        }
        
        if (string.IsNullOrEmpty(operation.Content))
        {
            Console.WriteLine($"❌ Insert operation has no content");
            return false;
        }
        
        return true;
    }
    
    /// <summary>
    /// Validate delete operation bounds before application
    /// </summary>
    private bool ValidateDeleteOperation(TextOperation operation, string currentContent)
    {
        if (operation.Position < 0 || operation.Position >= currentContent.Length)
        {
            Console.WriteLine($"❌ Delete operation position {operation.Position} is out of bounds (content length: {currentContent.Length})");
            return false;
        }
        
        if (operation.Length <= 0)
        {
            Console.WriteLine($"❌ Delete operation has invalid length: {operation.Length}");
            return false;
        }
        
        if (operation.Position + operation.Length > currentContent.Length)
        {
            Console.WriteLine($"❌ Delete operation extends beyond content bounds: pos={operation.Position}, len={operation.Length}, content length={currentContent.Length}");
            // Adjust length to fit within bounds
            var adjustedLength = currentContent.Length - operation.Position;
            if (adjustedLength > 0)
            {
                Console.WriteLine($"⚠️ Adjusting delete length from {operation.Length} to {adjustedLength}");
                operation.Length = adjustedLength;
                return true;
            }
            return false;
        }
        
        return true;
    }
    
    /// <summary>
    /// Validate replace operation bounds before application
    /// </summary>
    private bool ValidateReplaceOperationForApplication(TextOperation operation, string currentContent)
    {
        if (operation.SelectionStart < 0 || operation.SelectionStart > currentContent.Length)
        {
            Console.WriteLine($"❌ Replace operation start {operation.SelectionStart} is out of bounds (content length: {currentContent.Length})");
            return false;
        }
        
        if (operation.SelectionEnd < operation.SelectionStart || operation.SelectionEnd > currentContent.Length)
        {
            Console.WriteLine($"❌ Replace operation end {operation.SelectionEnd} is invalid (start: {operation.SelectionStart}, content length: {currentContent.Length})");
            
            // Attempt to adjust selection end to be valid
            var adjustedEnd = Math.Min(Math.Max(operation.SelectionStart, operation.SelectionEnd), currentContent.Length);
            if (adjustedEnd != operation.SelectionEnd)
            {
                Console.WriteLine($"⚠️ Adjusting selection end from {operation.SelectionEnd} to {adjustedEnd}");
                operation.SelectionEnd = adjustedEnd;
            }
            
            return adjustedEnd > operation.SelectionStart || !string.IsNullOrEmpty(operation.Content);
        }
        
        return true;
    }

    private async Task BroadcastCursor()
    {
        if (!IsCollaborationEnabled || _editHubConnection?.State != HubConnectionState.Connected)
            return;

        // Skip cursor broadcasting if we're currently processing operations
        if (_isProcessingOperation)
        {
            Console.WriteLine($"⏭️ Skipping cursor broadcast - processing operation");
            return;
        }

        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            var userId = httpContext?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? 
                        httpContext?.User?.FindFirst("sub")?.Value ?? 
                        "";

            if (string.IsNullOrEmpty(userId)) return;

            var cursorInfo = await JS.InvokeAsync<int[]>("getEditorCursorPosition", _editorId);
            if (cursorInfo?.Length >= 2)
            {
                var currentStart = cursorInfo[0];
                var currentEnd = cursorInfo[1];
                
                // Only broadcast if cursor position has changed and we have pending operations count < 3 (to reduce noise)
                if ((currentStart != _lastCursorStart || currentEnd != _lastCursorEnd) && _pendingOperations.Count < 3)
                {
                    var cursor = new CursorPosition
                    {
                        UserId = userId,
                        Start = currentStart,
                        End = currentEnd
                    };

                    await _editHubConnection.InvokeAsync("SendCursorUpdate", PageId.ToString(), cursor);
                    
                    // Update last known position
                    _lastCursorStart = currentStart;
                    _lastCursorEnd = currentEnd;
                    
                    Console.WriteLine($"📍 Broadcasted cursor position: {currentStart}-{currentEnd}");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to broadcast cursor: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnTextChange(string newContent, int position, string changeType, string text)
    {
        if (!IsCollaborationEnabled || _editHubConnection?.State != HubConnectionState.Connected)
            return;

        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            var userId = httpContext?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? 
                        httpContext?.User?.FindFirst("sub")?.Value ?? 
                        Guid.NewGuid().ToString();

            TextOperation? operation = null;

            if (changeType == "insert")
            {
                operation = TextOperation.Insert(position, text, userId);
            }
            else if (changeType == "delete")
            {
                operation = TextOperation.Delete(position, text.Length, userId);
            }

            if (operation != null)
            {
                // Store content backup before sending operation for potential rollback
                var contentBeforeOperation = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
                _operationContentBackup[operation.OperationId] = contentBeforeOperation;
                _pendingOperationMap[operation.OperationId] = operation;
                
                _pendingOperations.Enqueue(operation);
                _localOperationCounter++;
                
                Console.WriteLine($"📤 SENDING local operation:");
                Console.WriteLine($"   Type: {operation.OpType}, Position: {operation.Position}, Content: '{operation.Content}'");
                Console.WriteLine($"   OpId: {operation.OperationId}, User: {userId}");
                Console.WriteLine($"   Content before: length {contentBeforeOperation?.Length}, Pending count: {_pendingOperations.Count}");
                
                await _editHubConnection.InvokeAsync("SendTextOperation", PageId.ToString(), operation);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to send text operation: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnTextReplace(int selectionStart, int selectionEnd, string newText)
    {
        if (!IsCollaborationEnabled || _editHubConnection?.State != HubConnectionState.Connected)
        {
            Console.WriteLine($"⏭️ Replace operation skipped - collaboration not enabled or not connected");
            return;
        }

        try
        {
            var httpContext = HttpContextAccessor.HttpContext;
            var userId = httpContext?.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? 
                        httpContext?.User?.FindFirst("sub")?.Value ?? 
                        Guid.NewGuid().ToString();

            // Enhanced logging for Replace operations
            Console.WriteLine($"📝 Creating Replace operation:");
            Console.WriteLine($"   Selection: {selectionStart}-{selectionEnd} (length: {selectionEnd - selectionStart})");
            Console.WriteLine($"   New text: '{newText}' (length: {newText?.Length ?? 0})");
            Console.WriteLine($"   User: {userId}");

            var operation = TextOperation.Replace(selectionStart, selectionEnd, newText, userId);
            
            // Validate the created operation
            if (!IsOperationValid(operation))
            {
                Console.WriteLine($"❌ Created Replace operation is invalid, aborting send");
                return;
            }
            
            // Store content backup before sending operation for potential rollback
            var contentBeforeOperation = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            Console.WriteLine($"💾 Backing up content (length: {contentBeforeOperation?.Length}) for operation {operation.OperationId}");
            
            _operationContentBackup[operation.OperationId] = contentBeforeOperation;
            _pendingOperationMap[operation.OperationId] = operation;
            
            _pendingOperations.Enqueue(operation);
            _localOperationCounter++;
            
            Console.WriteLine($"📤 Sending Replace operation {operation.OperationId} to server (pending count: {_pendingOperations.Count})");
            await _editHubConnection.InvokeAsync("SendTextOperation", PageId.ToString(), operation);
            
            Console.WriteLine($"✅ Replace operation sent successfully: {selectionStart}-{selectionEnd} -> '{newText}'");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Failed to send text replace operation: {ex.Message}");
            Console.WriteLine($"   Stack trace: {ex.StackTrace}");
        }
    }

    // Phase 1: Enhanced State Reconciliation Methods
    
    /// <summary>
    /// Phase 1: Perform periodic state synchronization with server
    /// Compares client content hash and sequence number with server
    /// </summary>
    private async Task PerformStateSync()
    {
        if (!IsCollaborationEnabled)
        {
            Console.WriteLine($"⏭️ State sync skipped - collaboration not enabled");
            return;
        }
        
        if (_editHubConnection?.State != HubConnectionState.Connected)
        {
            Console.WriteLine($"⏭️ State sync skipped - not connected (state: {_editHubConnection?.State})");
            return;
        }

        try
        {
            var currentContent = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            var contentHash = ComputeContentHash(currentContent);
            
            Console.WriteLine($"🔍 Requesting state sync - seq: {_lastKnownSequenceNumber}, content length: {currentContent?.Length}, hash: {contentHash[..8]}...");
            
            await _editHubConnection.InvokeAsync("RequestStateSync", 
                PageId.ToString(), 
                _lastKnownSequenceNumber, 
                contentHash);
                
            Console.WriteLine($"✅ State sync request sent successfully");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ State sync failed: {ex.Message}");
            Console.WriteLine($"   Stack trace: {ex.StackTrace}");
        }
    }
    
    /// <summary>
    /// Phase 1: Handle successful state verification from server
    /// </summary>
    private Task OnStateVerified(long serverSequenceNumber)
    {
        Console.WriteLine($"✅ State verified - client and server in sync at sequence {serverSequenceNumber}");
        return Task.CompletedTask;
    }
    
    /// <summary>
    /// Phase 1: Handle required resync from server when state diverges
    /// Improved to preserve and replay valid local operations
    /// </summary>
    private async Task OnRequiredResync(string serverContent, long serverSequenceNumber, string serverHash)
    {
        Console.WriteLine($"🚨 DESYNC DETECTED - attempting smart resync");
        Console.WriteLine($"   Server seq: {serverSequenceNumber}, Client seq: {_lastKnownSequenceNumber}");
        Console.WriteLine($"   Server hash: {serverHash[..8]}..., Content length: {serverContent?.Length}");
        Console.WriteLine($"   Pending operations to preserve: {_pendingOperations.Count}");
        
        try
        {
            // Store pending operations for potential replay
            var pendingOpsToReplay = new List<TextOperation>();
            var currentTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
            
            // Identify recent operations that might still be valid
            foreach (var op in _pendingOperations)
            {
                // Only replay operations from the last 5 seconds to avoid stale operations
                var operationAge = currentTime - op.Timestamp;
                if (operationAge < 5000) // 5 seconds
                {
                    Console.WriteLine($"🔄 Marking operation for replay: {op.OpType} at {op.Position} (age: {operationAge}ms)");
                    pendingOpsToReplay.Add(op);
                }
                else
                {
                    Console.WriteLine($"🗑️ Discarding stale operation: {op.OpType} at {op.Position} (age: {operationAge}ms)");
                }
            }
            
            // Apply server content first
            await JS.InvokeVoidAsync("setEnhancedEditorContent", _editorId, serverContent);
            _lastKnownSequenceNumber = serverSequenceNumber;
            
            // Clear all pending operation tracking
            _pendingOperations.Clear();
            _pendingOperationMap.Clear();
            _operationContentBackup.Clear();
            
            Console.WriteLine($"✅ Applied server state, attempting to replay {pendingOpsToReplay.Count} recent operations");
            
            // Attempt to replay recent local operations
            if (pendingOpsToReplay.Count > 0 && IsCollaborationEnabled && _editHubConnection?.State == HubConnectionState.Connected)
            {
                var replayedCount = 0;
                foreach (var op in pendingOpsToReplay)
                {
                    try
                    {
                        // Validate operation is still applicable
                        var currentContent = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
                        if (IsOperationApplicable(op, currentContent))
                        {
                            // Apply locally first to maintain immediate user feedback
                            await ApplyOperationToEditor(op);
                            
                            // Create new operation with updated timestamp
                            var replayOp = new TextOperation
                            {
                                OpType = op.OpType,
                                Position = op.Position,
                                Content = op.Content,
                                Length = op.Length,
                                UserId = op.UserId,
                                Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(), // New timestamp
                                SelectionStart = op.SelectionStart,
                                SelectionEnd = op.SelectionEnd,
                                OperationId = Guid.NewGuid().ToString() // New ID
                            };
                            
                            // Re-send to server
                            await _editHubConnection.InvokeAsync("SendTextOperation", PageId.ToString(), replayOp);
                            
                            // Track the replayed operation
                            _pendingOperations.Enqueue(replayOp);
                            _pendingOperationMap[replayOp.OperationId] = replayOp;
                            
                            replayedCount++;
                            Console.WriteLine($"✅ Replayed operation: {op.OpType} at {op.Position}");
                        }
                        else
                        {
                            Console.WriteLine($"⚠️ Operation no longer applicable: {op.OpType} at {op.Position}");
                        }
                    }
                    catch (Exception replayEx)
                    {
                        Console.WriteLine($"❌ Failed to replay operation {op.OpType}: {replayEx.Message}");
                    }
                }
                
                Console.WriteLine($"✅ Smart resync completed: replayed {replayedCount}/{pendingOpsToReplay.Count} operations");
            }
            else
            {
                Console.WriteLine($"✅ Basic resync completed (no operations to replay)");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Resync failed: {ex.Message}");
            Console.WriteLine($"   Stack trace: {ex.StackTrace}");
            
            // Fallback to basic resync
            try
            {
                await JS.InvokeVoidAsync("setEnhancedEditorContent", _editorId, serverContent);
                _lastKnownSequenceNumber = serverSequenceNumber;
                _pendingOperations.Clear();
                _pendingOperationMap.Clear();
                _operationContentBackup.Clear();
                Console.WriteLine($"✅ Fallback resync completed");
            }
            catch (Exception fallbackEx)
            {
                Console.WriteLine($"❌ Fallback resync also failed: {fallbackEx.Message}");
            }
        }
    }
    
    /// <summary>
    /// Check if an operation can still be applied to the current content
    /// </summary>
    private bool IsOperationApplicable(TextOperation operation, string currentContent)
    {
        if (string.IsNullOrEmpty(currentContent))
            return false;
            
        switch (operation.OpType)
        {
            case TextOperation.OperationType.Insert:
                // Insert is applicable if position is within content bounds
                return operation.Position >= 0 && operation.Position <= currentContent.Length;
                
            case TextOperation.OperationType.Delete:
                // Delete is applicable if we have enough content to delete
                return operation.Position >= 0 && 
                       operation.Position + operation.Length <= currentContent.Length;
                       
            case TextOperation.OperationType.Replace:
                // Replace is applicable if selection bounds are valid
                return operation.SelectionStart >= 0 && 
                       operation.SelectionEnd <= currentContent.Length &&
                       operation.SelectionStart <= operation.SelectionEnd;
                       
            default:
                return false;
        }
    }
    
    /// <summary>
    /// Compute SHA-256 hash of content for state verification (client-side)
    /// </summary>
    private static string ComputeContentHash(string content)
    {
        using var sha256 = System.Security.Cryptography.SHA256.Create();
        var bytes = System.Text.Encoding.UTF8.GetBytes(content ?? "");
        var hash = sha256.ComputeHash(bytes);
        return Convert.ToBase64String(hash);
    }

}

