@using Microsoft.JSInterop
@using System.Text.Json
@using System.Text
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject HttpClient HttpClient
@inject IHttpContextAccessor HttpContextAccessor

<div class="editor-container" id="editor-container-@_editorId" data-editor-id="@_editorId" data-format="@BodyFormat">
    <!-- Hidden field for this editor instance -->
    <input type="hidden" name="Body" data-role="body" value="@_safeContent" />
    <!-- Format badge for this editor -->
    <span data-role="format-badge" style="display: none;">@BodyFormat</span>
    
    <div class="editor-toolbar mb-2">
        <div class="d-flex justify-content-between align-items-center">
            <div class="btn-group btn-group-sm" role="group">
                <button type="button" class="btn btn-outline-secondary" disabled="@(!IsFullyReady)" data-action="save-draft">
                    Save Draft
                </button>
                <button type="button" class="btn btn-primary" disabled="@(!IsFullyReady)" data-action="commit-changes">
                    Commit Changes
                </button>
            </div>
            <div class="editor-status d-flex gap-2">
                @if (HasDraft && !IsNewPage)
                {
                    <span class="badge bg-info" title="This page has uncommitted draft content">
                        <i class="bi bi-pencil-square me-1"></i>Draft
                        @if (LastDraftAt.HasValue)
                        {
                            <small> (@LastDraftAt.Value.ToString("HH:mm"))</small>
                        }
                    </span>
                }
                @if (IsFullyReady)
                {
                    <span class="badge bg-success">Ready</span>
                }
                else if (IsReady && !IsBlazorConnected)
                {
                    <span class="badge bg-warning">Connecting...</span>
                }
                else
                {
                    <span class="badge bg-warning">Loading...</span>
                }
            </div>
        </div>
    </div>

    <div class="row">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header py-2">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">Editor</h6>
                        <div class="btn-group btn-group-sm" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" disabled="@(!IsFullyReady)" data-action="insert-bold" title="Bold (Ctrl+B)">
                                <strong>B</strong>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Italic (Ctrl+I)">
                                <em>I</em>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Inline Code">
                                <code>&lt;/&gt;</code>
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Code Block">
                                <code>{ }</code>
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm ms-2" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 1">
                                H1
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 2">
                                H2
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Header 3">
                                H3
                            </button>
                        </div>
                        <div class="btn-group btn-group-sm ms-2" role="group">
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Unordered List">
                                List
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Ordered List">
                                1. List
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Blockquote">
                                Quote
                            </button>
                            <button type="button" class="btn btn-outline-secondary btn-sm" title="Link">
                                Link
                            </button>
                        </div>
                    </div>
                </div>
                <div class="card-body p-0" style="position: relative;">
                    <textarea id="@_editorId" 
                              class="form-control border-0" 
                              rows="20" 
                              placeholder="@(BodyFormat == "markdown" ? "Start writing your wiki content in Markdown..." : "Start writing your wiki content in HTML...")"
                              data-room="@_safeRoom"
                              data-role="editor"
                              style="resize: vertical; min-height: 400px; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 14px; line-height: 1.5;">@_safeContent</textarea>
                    
                    <!-- Drag and Drop Overlay -->
                    <div id="drag-drop-overlay-@_editorId" class="drag-drop-overlay d-none">
                        <div class="drag-drop-content">
                            <i class="bi bi-cloud-arrow-up display-1 text-primary"></i>
                            <h4 class="mt-3">Drop images here to upload</h4>
                            <p class="text-muted">Supported formats: JPG, PNG, GIF, WebP</p>
                        </div>
                    </div>
                </div>
                <div class="card-footer py-2">
                    <div class="d-flex justify-content-between">
                        <small class="text-muted">
                            <span data-role="word-count">0 words</span> | 
                            <span data-role="char-count">0 characters</span>
                        </small>
                        <small class="text-muted">
                            <span data-role="status">Ready</span>
                        </small>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-6">
            <div class="card">
                <div class="card-header py-2">
                    <h6 class="mb-0">Preview</h6>
                </div>
                <div class="card-body" style="min-height: 400px; max-height: 500px; overflow-y: auto;">
                    <div data-role="preview" class="markdown-content">
                        <em>Preview will appear here...</em>
                    </div>
                </div>
                <div class="card-footer py-2">
                    <small class="text-muted">
                        Collaborative editing enabled
                    </small>
                </div>
            </div>
        </div>
    </div>
</div>

@code {
    [Parameter] 
    public string InitialContentRaw { get; set; } = "";
    
    [Parameter] 
    public string YjsRoomRaw { get; set; } = "";
    
    [Parameter] 
    public Guid PageId { get; set; }
    
    [Parameter]
    public string BodyFormat { get; set; } = "markdown";
    
    [Parameter]
    public bool HasDraft { get; set; }
    
    [Parameter]
    public DateTimeOffset? LastDraftAt { get; set; }
    
    [Parameter]
    public DateTimeOffset? LastCommittedAt { get; set; }
    
    // Safe versions for DOM use
    private string _editorId = $"simple-editor-{Guid.NewGuid():N}";
    private string _safeRoom = "";
    private string _safeContent = "";
    
    private bool IsReady = false;
    private bool IsBlazorConnected = false;
    private bool IsFullyReady => IsReady && IsBlazorConnected;
    private bool IsNewPage => PageId == Guid.Empty;
    private Timer? AutosaveTimer = null;
    private Timer? ImmediateAutoSaveTimer = null;
    private CancellationTokenSource? _cancellationTokenSource = new();
    private readonly SemaphoreSlim _autosaveSemaphore = new(1, 1);
    
    // Single-user editor state
    
    // Unique component instance ID for debugging
    private readonly string ComponentId = Guid.NewGuid().ToString("N")[..8];
    private int RenderCount = 0;
    private int MethodCallCount = 0;
    
    // Draft discard coordination state
    private bool _isDiscardingDraft = false;
    private DateTime? _lastDiscardTime = null;
    private readonly object _discardLock = new object();

    protected override void OnInitialized()
    {
        // Sanitize inputs during initialization
        _safeContent = StripFormatChars(InitialContentRaw);
        _safeRoom = SafeDomToken(YjsRoomRaw);
        
        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        // Re-sanitize inputs when parameters change
        _safeContent = StripFormatChars(InitialContentRaw);
        _safeRoom = SafeDomToken(YjsRoomRaw);
        
        base.OnParametersSet();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"üöÄ OnAfterRenderAsync called - firstRender: {firstRender}, PageId: {PageId}");
        if (firstRender)
        {
            try
            {
                Console.WriteLine($"üîß Starting first render initialization for page {PageId}");
                // Wait a bit to ensure Blazor is fully loaded
                await Task.Delay(100);
                
                // Check Blazor connection state
                try 
                {
                    IsBlazorConnected = await JS.InvokeAsync<bool>("checkBlazorConnection");
                }
                catch
                {
                    IsBlazorConnected = false;
                }
                
                // Re-render with connection state
                if (IsBlazorConnected)
                {
                    StateHasChanged();
                    await Task.Delay(50);
                }
                
                // Create .NET object reference and initialize NEW modular editor
                var objRef = DotNetObjectReference.Create(this);
                var success = await JS.InvokeAsync<bool>("initWikiEditor", $"editor-container-{_editorId}", _safeContent, BodyFormat, objRef);
                Console.WriteLine($"üìù NEW Editor initialization success: {success} for page {PageId}");
                
                if (success)
                {
                    Console.WriteLine($"‚úÖ Editor ready for page {PageId}");
                    IsReady = true;
                    
                    Console.WriteLine($"‚úÖ Single-user editor initialized for page {PageId}");
                    
                    // Start autosave timer for all pages (reduced frequency since we have immediate saves)
                    AutosaveTimer = new Timer(async _ => await AutoSave(), null, 
                        TimeSpan.FromSeconds(60), TimeSpan.FromSeconds(60)); // Reduced to 60 seconds
                    
                    // Set up immediate auto-save on content changes (works for all pages)
                    await JS.InvokeVoidAsync("setupImmediateAutoSave", _editorId);
                }
                
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"‚ùå EditorSimple initialization failed for page {PageId}: {ex.Message}");
                Console.WriteLine($"‚ùå Exception details: {ex}");
                IsReady = false;
                IsBlazorConnected = false;
                StateHasChanged();
            }
        }
    }

    private async Task SaveDraft()
    {
        if (!IsFullyReady || IsNewPage) 
        {
            await JS.InvokeVoidAsync("showEditorStatus", "Save not available for new pages");
            return;
        }
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            var request = new { Content = content };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/autosave", httpContent, _cancellationTokenSource?.Token ?? default);
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Draft saved");
                    await JS.InvokeVoidAsync("markContentAsSaved");
                }
                catch
                {
                    await JS.InvokeVoidAsync("showEditorStatus", "Save failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                await JS.InvokeVoidAsync("showEditorStatus", "Save failed - authentication required");
            }
            else
            {
                await JS.InvokeVoidAsync("showEditorStatus", $"Save failed: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå SaveDraft failed: {ex.Message}");
            await JS.InvokeVoidAsync("showEditorStatus", $"Save failed: {ex.Message}");
        }
    }

    private async Task CommitChanges()
    {
        if (!IsFullyReady || IsNewPage) 
        {
            await JS.InvokeVoidAsync("showEditorStatus", "Use the main Save button to create new pages");
            return;
        }
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            var request = new { Content = content, Summary = "Updated via enhanced editor" };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/commit", httpContent, _cancellationTokenSource?.Token ?? default);
            var responseContent = await response.Content.ReadAsStringAsync();
            Console.WriteLine($"CommitChanges() response status: {response.StatusCode}");
            Console.WriteLine($"CommitChanges() response content: {responseContent}");
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Changes committed successfully");
                    // Notify that changes have been committed via API
                    await JS.InvokeVoidAsync("markContentAsCommitted");
                    await JS.InvokeVoidAsync("markContentAsSaved");
                }
                catch
                {
                    // Not JSON, probably HTML - treat as error even with 200 status
                    await JS.InvokeVoidAsync("showEditorStatus", "Commit failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                await JS.InvokeVoidAsync("showEditorStatus", "Commit failed - authentication required. Please refresh and log in again.");
            }
            else
            {
                await JS.InvokeVoidAsync("showEditorStatus", $"Commit failed: {response.StatusCode} - {responseContent}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå CommitChanges failed: {ex.Message}");
            await JS.InvokeVoidAsync("showEditorStatus", $"Commit failed: {ex.Message}");
        }
    }

    private async Task AutoSave()
    {
        if (!IsReady || _cancellationTokenSource?.Token.IsCancellationRequested == true) return;
        
        // For new pages, we can't auto-save to the API yet, but we can still track changes
        if (IsNewPage)
        {
            Console.WriteLine("‚è∏Ô∏è Autosave skipped for new page - no PageId available");
            return;
        }
        
        // Prevent overlapping autosave operations
        if (!await _autosaveSemaphore.WaitAsync(0, _cancellationTokenSource?.Token ?? default))
        {
            Console.WriteLine("‚è∏Ô∏è Autosave skipped - another save in progress");
            return;
        }
        
        try
        {
            // Check if we're currently discarding a draft or recently did
            lock (_discardLock)
            {
                if (_isDiscardingDraft)
                {
                    Console.WriteLine("‚è∏Ô∏è Autosave paused - draft discard in progress");
                    return;
                }
                
                // Don't autosave for 2 minutes after a draft discard to prevent race conditions
                if (_lastDiscardTime.HasValue && DateTime.UtcNow.Subtract(_lastDiscardTime.Value).TotalMinutes < 2)
                {
                    Console.WriteLine("‚è∏Ô∏è Autosave paused - recent draft discard detected");
                    return;
                }
            }
        
        try
        {
            var content = await JS.InvokeAsync<string>("getEnhancedEditorContent", _editorId);
            if (string.IsNullOrEmpty(content))
            {
                Console.WriteLine("Autosave skipped - no content");
                return;
            }
            
            // Single-user autosave - no sync needed
            
            var request = new { Content = content };
            var json = JsonSerializer.Serialize(request);
            var httpContent = new StringContent(json, Encoding.UTF8, "application/json");
            
            var response = await MakeAuthenticatedRequest($"/api/wiki/{PageId}/autosave", httpContent, _cancellationTokenSource?.Token ?? default);
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Check if we got redirected to login page (auth failure)
            bool isLoginPage = responseContent.Contains("<title>dex</title>") || 
                              responseContent.Contains("Log in to Your Account") ||
                              responseContent.Contains("/dex/auth/");
            
            if (response.IsSuccessStatusCode && !isLoginPage)
            {
                // Try to parse as JSON to verify it's a real API response
                try
                {
                    using var jsonDoc = System.Text.Json.JsonDocument.Parse(responseContent);
                    await JS.InvokeVoidAsync("showEditorStatus", "Auto-saved");
                    await JS.InvokeVoidAsync("markContentAsSaved");
                }
                catch
                {
                    Console.WriteLine("Autosave failed - unexpected response format");
                }
            }
            else if (isLoginPage)
            {
                Console.WriteLine("Autosave failed - authentication required");
            }
            else
            {
                Console.WriteLine($"Autosave failed with status: {response.StatusCode}");
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when component is being disposed - don't log as error
            Console.WriteLine("üîÑ Autosave canceled (component disposing)");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Autosave error: {ex.Message}");
        }
        }
        finally
        {
            _autosaveSemaphore.Release();
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Cancel any ongoing autosave operations
        _cancellationTokenSource?.Cancel();
        
        AutosaveTimer?.Dispose();
        ImmediateAutoSaveTimer?.Dispose();
        
        try
        {
            if (IsReady)
            {
                await JS.InvokeVoidAsync("destroyEnhancedEditor", _editorId);
            }
        }
        catch
        {
            // Best effort cleanup
        }
        
        _cancellationTokenSource?.Dispose();
        _autosaveSemaphore.Dispose();
    }

    // Helper method to make authenticated HTTP requests with cookies
    private async Task<HttpResponseMessage> MakeAuthenticatedRequest(string url, HttpContent content, CancellationToken cancellationToken = default)
    {
        var httpContext = HttpContextAccessor.HttpContext;
        if (httpContext == null)
        {
            // Fallback to regular HttpClient if no context available
            return await HttpClient.PostAsync(url, content, cancellationToken);
        }

        // Create a new HttpClient that includes authentication cookies
        var handler = new HttpClientHandler()
        {
            UseCookies = true
        };

        using var authenticatedClient = new HttpClient(handler);
        
        // Set timeout to prevent hung connections
        authenticatedClient.Timeout = TimeSpan.FromSeconds(30);
        
        // Set base URL
        var baseUrl = await JS.InvokeAsync<string>("eval", "window.location.origin");
        authenticatedClient.BaseAddress = new Uri(baseUrl);
        
        // Copy authentication cookies from current request
        var cookieHeader = httpContext.Request.Headers["Cookie"].ToString();
        if (!string.IsNullOrEmpty(cookieHeader))
        {
            authenticatedClient.DefaultRequestHeaders.Add("Cookie", cookieHeader);
        }
        
        // Copy authorization headers if present
        if (httpContext.Request.Headers.ContainsKey("Authorization"))
        {
            var authHeader = httpContext.Request.Headers["Authorization"].ToString();
            authenticatedClient.DefaultRequestHeaders.Add("Authorization", authHeader);
        }
        
        return await authenticatedClient.PostAsync(url, content, cancellationToken);
    }

    private async Task InsertMarkdown(string before, string after)
    {
        try
        {
            await JS.InvokeVoidAsync("insertMarkdown", before, after);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error inserting markdown: {ex.Message}");
        }
    }


    // Individual button handlers
    private async Task InsertBold() => await InsertMarkdown("**", "**");
    private async Task InsertItalic() => await InsertMarkdown("*", "*");

    private async Task InsertInlineCode() => await InsertMarkdown("`", "`");
    private async Task InsertCodeBlock() => await InsertMarkdown("```\n", "\n```");
    private async Task InsertHeader1() => await InsertMarkdown("# ", "");
    private async Task InsertHeader2() => await InsertMarkdown("## ", "");
    private async Task InsertHeader3() => await InsertMarkdown("### ", "");
    private async Task InsertList() => await InsertMarkdown("- ", "");
    private async Task InsertOrderedList() => await InsertMarkdown("1. ", "");
    private async Task InsertBlockquote() => await InsertMarkdown("> ", "");
    private async Task InsertLink() => await InsertMarkdown("[", "](url)");
    
    /// <summary>
    /// Remove BOM and other format characters that can cause DOM InvalidCharacterError
    /// </summary>
    static string StripFormatChars(string s)
    {
        if (string.IsNullOrEmpty(s)) return string.Empty;
        
        // More aggressive BOM and format character removal
        var cleaned = s;
        
        // Remove BOM variants
        cleaned = cleaned.Replace("\uFEFF", ""); // UTF-8 BOM
        cleaned = cleaned.Replace("\uFFFE", ""); // UTF-16 BOM
        cleaned = cleaned.Replace("\u0000FEFF", ""); // Alternative BOM representation
        
        // Remove zero-width characters
        cleaned = cleaned.Replace("\u200B", ""); // Zero Width Space
        cleaned = cleaned.Replace("\u200C", ""); // Zero Width Non-Joiner  
        cleaned = cleaned.Replace("\u200D", ""); // Zero Width Joiner
        cleaned = cleaned.Replace("\u2060", ""); // Word Joiner
        cleaned = cleaned.Replace("\u180E", ""); // Mongolian Vowel Separator
        
        // Keep only printable characters + tab/newline/carriage return
        cleaned = new string(cleaned.Where(c => c >= ' ' || c is '\t' or '\n' or '\r').ToArray());
        
        return cleaned;
    }

    /// <summary>
    /// Create DOM-safe token from user input (for IDs, classes, attribute names)
    /// </summary>
    static string SafeDomToken(string s)
    {
        s = StripFormatChars(s ?? "");
        s = System.Text.RegularExpressions.Regex.Replace(s, @"[^\w\-]", ""); // only [A-Za-z0-9_-]
        return string.IsNullOrEmpty(s) ? "room" : s;
    }

    // JavaScript-invokable methods for button actions
    [JSInvokable]
    public async Task HandleSaveDraft()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"üéØ [{ComponentId}:{callId}] HandleSaveDraft called from JavaScript");
        await SaveDraft();
        Console.WriteLine($"‚úÖ [{ComponentId}:{callId}] HandleSaveDraft completed");
    }

    [JSInvokable] 
    public async Task HandleCommitChanges()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"üéØ [{ComponentId}:{callId}] HandleCommitChanges called from JavaScript");
        await CommitChanges();
        Console.WriteLine($"‚úÖ [{ComponentId}:{callId}] HandleCommitChanges completed");
    }

    [JSInvokable]
    public async Task HandleInsertBold()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"üéØ [{ComponentId}:{callId}] HandleInsertBold called from JavaScript");
        await InsertBold();
        Console.WriteLine($"‚úÖ [{ComponentId}:{callId}] HandleInsertBold completed");
    }
    
    [JSInvokable]
    public async Task BeginDiscardDraft()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"üéØ [{ComponentId}:{callId}] BeginDiscardDraft called from JavaScript");
        
        // Set draft discard coordination state to pause autosave and state sync
        lock (_discardLock)
        {
            _isDiscardingDraft = true;
            _lastDiscardTime = DateTime.UtcNow;
            Console.WriteLine($"üö´ Draft discard state activated - autosave paused");
        }
        
        Console.WriteLine($"‚úÖ [{ComponentId}:{callId}] BeginDiscardDraft completed - timers paused");
    }
    
    [JSInvokable]
    public async Task EndDiscardDraft()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"üéØ [{ComponentId}:{callId}] EndDiscardDraft called from JavaScript");
        
        // Clear the immediate discard flag but keep the timestamp
        lock (_discardLock)
        {
            _isDiscardingDraft = false;
            // _lastDiscardTime remains set to prevent autosave for 2 minutes
            Console.WriteLine($"‚úÖ Draft discard completed - autosave will remain paused for 2 minutes");
        }
        
        Console.WriteLine($"‚úÖ [{ComponentId}:{callId}] EndDiscardDraft completed");
    }
    
    [JSInvokable]
    public async Task TriggerImmediateAutoSave()
    {
        var callId = ++MethodCallCount;
        Console.WriteLine($"üéØ [{ComponentId}:{callId}] TriggerImmediateAutoSave called from JavaScript");
        
        // Use a timer to debounce rapid changes (save 2 seconds after last change)
        ImmediateAutoSaveTimer?.Dispose();
        ImmediateAutoSaveTimer = new Timer(async _ => {
            Console.WriteLine($"üíæ [{ComponentId}:{callId}] Executing immediate auto-save");
            await AutoSave();
            ImmediateAutoSaveTimer?.Dispose();
            ImmediateAutoSaveTimer = null;
        }, null, TimeSpan.FromSeconds(2), Timeout.InfiniteTimeSpan);
        
        Console.WriteLine($"‚úÖ [{ComponentId}:{callId}] Immediate auto-save scheduled (2 second delay)");
    }
    
    // Stub methods for collaboration system (not used in single-user editor)
    [JSInvokable]
    public async Task OnTextChange(string content, int position, string changeType, string changeContent)
    {
        // This is called by the collaboration plugin but we don't need it for single-user editing
        // Just log and ignore to prevent JavaScript errors
        Console.WriteLine($"üîÑ [{ComponentId}] OnTextChange ignored (single-user mode): {changeType} at {position}");
        await Task.CompletedTask;
    }
    
    [JSInvokable]
    public async Task OnTextReplace(int start, int end, string content)
    {
        // This is called by the collaboration plugin but we don't need it for single-user editing
        // Just log and ignore to prevent JavaScript errors
        Console.WriteLine($"üîÑ [{ComponentId}] OnTextReplace ignored (single-user mode): {start}-{end}");
        await Task.CompletedTask;
    }
}